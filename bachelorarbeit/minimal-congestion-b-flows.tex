\chapter{Auslastungsminimale $b$-Flüsse}

Ein effiziente Berechnung von Nash-Gleichgewichten erfordert zunächst Verständnis von speziellen Klassen von statischen Flüssen.
Eine wichtige Klasse sind die sogenannten auslastungsminimalen $b$-Flüsse:

\begin{definition}[Auslastungsminimaler $b$-Fluss]
	Sei ein $b$-Fluss $f$ auf einem Netzwerk ohne Schleifen mit Kapazitäten $u\in\R_{>0}^E$ gegeben.
	Dann heißt $f_e/u_e$ die \emph{Auslastung der Kante $e$ durch $f$} und die maximale Kantenauslastung $c(f):=\max_{e\in E} f_e/u_e$ bezeichnet die \emph{Auslastung des Flusses $f$}.
	Eine Kante mit Auslastung $c(f)$ wird auch als \emph{Flaschenhalskante} (engl. bottleneck edge) bezeichnet.
	Ein $b$-Fluss mit minimaler Auslastung wird dann \emph{auslastungsminimaler $b$-Fluss} genannt.
\end{definition}

In diesem Kapitel wird nun ein Optimalitätskriterium und ein effizienter Algorithmus zur Berechnung solcher auslastungsminimaler $b$-Flüsse vorgestellt.
In diesem Kapitel nehmen wir an, dass keine Schleifen existieren, da diese bei der Berechnung auslastungsminimaler $b$-Flüsse ignoriert werden können.

\section{Optimalitätskriterium auslastungsminimaler $b$-Flüsse}

In diesem Abschnitt wird ein hinreichendes sowie notwendiges Kriterium auslastungsminimaler $b$-Flüsse erarbeitet.

Ähnlich zum wohlbekannten Max-Flow-Min-Cut-Theorem von Ford und Fulkerson betrachtet man dabei ein duales Problem, das die Auslastung von Schnitten involviert.

\begin{definition}[Schnitt]
	In einem gerichteten Netzwerk $(V, E, u)$ heißt eine Teilmenge $X\subseteq V$ \emph{Schnitt}, wobei die aus $X$ ausgehenden Kanten mit $\delta^+(X)$ und die in $X$ eingehenden Kanten mit $\delta^-(X)$ bezeichnet werden.
	
	Sind zusätzlich Knotenbalancen $b\in\R^V$ mit $\sum_{v\in V} b_v = 0$ gegeben und ist $\delta^+(X)$ nichtleer, so bezeichne $b(X) / u(\delta^+(X))$ die \emph{Auslastung des Schnittes $X$}.
	Dabei ist $b(X)$ bzw. $u(E')$ eine Kurzschreibweise für $\sum_{v\in X} b_v$ bzw. $\sum_{e\in E'} u_e$.
	Existiert ein Schnitt, dessen Auslastung maximal ist, so nennt man ihn einen \emph{dünnsten Schnitt}.
\end{definition}
Man bemerke, dass ein dünnster Schnitt existiert, wenn die Kantenmenge $E$ nichtleer ist.
\begin{definition}[Doppelgraph]
	Der Doppelgraph $G^\leftrightarrow$ eines Graphen $G=(V,E)$ ist das Paar $(V, \overrightsmallarrow{E}\cup \overleftsmallarrow{E})$, wobei $\overrightsmallarrow{E}:=\{ \overrightsmallarrow{e} \mid e\in E \}$ die Menge der Vorwärtskanten, die die Richtung der Ursprungskante beibehalten, und $\overleftsmallarrow{E}:=\{ \overleftsmallarrow{e} \mid e\in E \}$ die Menge der Rückswärtskanten, die die Richtung der Ursprungskante umkehren, sind.
\end{definition}
\begin{definition}[Residualgraph eines $b$-Flusses]
	Sei ein $b$-Fluss $f$ auf einem Netzwerk $(V, E)$ mit Kapazitäten $u\in\R^E_{>0}$ gegeben.
	Der \emph{Residualgraph von $G$ bezüglich $f$} ist definiert durch $G_f := (V, E_f)$ mit \[
	E_f := \{ \overrightsmallarrow{e}\in \overrightsmallarrow{E} \mid f_e/u_e < c(f) \} \cup \{ \overleftsmallarrow{e} \in \overleftsmallarrow{E} \mid f_e/u_e > 0 \}.
	\]
\end{definition}

\begin{lemma}\label{lemma-min-flow-criterion}
	Ist $f$ ein $b$-Fluss, dessen Residualgraph keine gerichteten Kreise besitzt, die eine Flaschenhalskante als Rückwärtskante benutzen, so ist $f$ auslastungsminimal.
\end{lemma}

Um diese Aussage zu zeigen, benötigt man folgende Hilfsproposition:

\begin{proposition}\label{prop-difference-b-flows-stream}
	Für zwei $b$-Flüsse $f$, $f'$ mit $c(f) \geq c(f')$ ist $f'\Delta f := g\in \R_{\geq0}^{E^\leftrightarrow}$, definiert durch
	\begin{align*}
	g_{\overrightsmallarrow{e}} := \max\{ 0, f_e' - f_e \} \text{~~~und~~~}
	g_{\overleftsmallarrow{e}} := \max\{ 0, f_e - f_e' \} \text{~~~für $e\in E$},
	\end{align*}
	eine Strömung auf $G^\leftrightarrow$, die auf $E^\leftrightarrow \setminus E_f$ verschwindet.
\end{proposition}
\begin{proof}
	Eine Strömung ist eine Kantenbewertung, die in jedem Knoten Flusserhaltung erhält.
	Man zeige also $g(\delta^+_{G^\leftrightarrow}(v)) - g(\delta^-_{G^\leftrightarrow}(v)) = 0$ für alle Knoten $v\in V$.
	Durch Fallunterscheidung erkenne man $g_{\overrightsmallarrow{e}} - g_{\overleftsmallarrow{e}} = f_e' - f_e$ für alle $e\in E$ und man folgere:
	\begin{align*}
	g(\delta^+_{G^\leftrightarrow}(v)) - g(\delta^-_{G^\leftrightarrow}(v))
	&= \left( \sum_{e\in\delta^+_G(v)} g_{\overrightsmallarrow{e}} +  \sum_{e\in\delta^-_G(v)} g_{\overleftsmallarrow{e}} \right)
	- \left(\sum_{e\in\delta^-_G(v)} g_{\overrightsmallarrow{e}} + \sum_{e\in\delta^+_G(v)} g_{\overleftsmallarrow{e}} \right) \\
	&= \sum_{e\in\delta^+_G(v)} (g_{\overrightsmallarrow{e}} - g_{\overleftsmallarrow{e}}) - \sum_{e\in\delta^-_G(v)} (g_{\overrightsmallarrow{e}} - g_{\overleftsmallarrow{e}})\\
	&= \sum_{e\in\delta^+_G(v)} (f_e' - f_e) - \sum_{e\in\delta^-_G(v)} (f_e' - f_e) = b_v - b_v = 0.
	\end{align*}
	Es bleibt also zu zeigen, dass $g$ auf $E^\leftrightarrow \setminus E_f$ verschwindet.
	Sei zunächst eine Vorwärtskante $\overrightsmallarrow{e}$ mit $f_{e}/u_{e} = c(f)$ gegeben.
	Dann gilt nach Voraussetzung auch $f_{e}/u_{e} = c(f) \geq c(f') \geq f'_{e}/u_{e}$, wodurch $g_{\overrightsmallarrow{e}}= 0$ folgt.
	Für eine Rückwärtskante $\overleftsmallarrow{e}$ mit $f_e = 0$ folgt $g_{\overleftsmallarrow{e}} = 0$ direkt.
\end{proof}

Insbesondere existiert für solche Strömungen $f'\Delta f$ eine Dekomposition in Zyklen.
Diese Eigenschaft wird im folgenden Beweis ausgenutzt:

\begin{proof}[Beweis von Lemma~\ref{lemma-min-flow-criterion}]
	Sei $f$ ein $b$-Fluss, dessen Residualgraph keine gerichteten Kreise mit einer Flaschenhalskante besitzt, und sei $e$ eine beliebige Flaschenhalskante.
	Angenommen, es existiere ein $b$-Fluss $f'$ mit geringerer Auslastung; es gilt also insbesondere $f'_e/u_e < f_e/u_e$.
	Die Strömung $g:= f'\Delta f$ besitzt nach Proposition~\ref{prop-difference-b-flows-stream} eine Dekomposition in Zyklen $g = \lambda_1 \cdot C_1 +\dots + \lambda_k \cdot C_k$ mit $\lambda_i > 0$ für $i\in[k]$.
	Da $g_{\overleftsmallarrow{e}}$ positiv ist, gibt es einen Zyklus $C_i$, der ${\overleftsmallarrow{e}}$ enthält.
	Da $g$ außerdem nur auf $E_f$ verläuft, enthält $E_f$ also den Zyklus $C_i$, der die Flaschenhalskante $e$ benutzt, was im Widerspruch zur Voraussetzung steht.
\end{proof}


\begin{lemma}\label{lemma-no-circle-in-res-graph-inclus-min}
	Sei $q^*$ die minimale Auslastung eines $b$-Flusses im Netzwerk $(V, E, u)$.
	Ist $E'\subseteq E$ inklusionsminimal mit der Eigenschaft, dass ein auslastungsminimaler $b$-Fluss $f$ mit Flaschenhalskanten $E'$ existiert, so enthält der Residualgraph $G_f$
	für solche Flüsse $f$ keine gerichteten Kreise, die eine Flaschenhalskante als Rückwärtskante benutzen.
\end{lemma}
\begin{proof}
	\newcommand{\VK}{\text{VK}}
	\newcommand{\RK}{\text{RK}}
	Angenommen, es existiere ein einfacher Kreis $C$, der eine Flaschenhalskante $e\in E$ als Rückwärtskante enthält.
	Es seien $C_\VK$ die Menge der Vorwärtskanten und $C_\RK$ die Menge der Rückwärtskanten in $C$.
	Man setze $\gamma_\VK := \min_{e\in C_\VK} q^*u_e - f_e > 0$ als die minimale Flussmenge, die man jeder Kante in $C_\VK$ zufügen müsste, sodass mindestens eine Kante darin mindestens Auslastung $q^*$ erhält.
	Weiter sei $\gamma_\RK := \min_{e^\leftarrow\in C_\RK} f_e > 0$ die minimale Flussmenge der Rückwärtskanten in $C$.
	Wählt man nun $0 < \gamma < \min\{ \gamma_\VK, \gamma_\RK  \}$, so erhält man durch Augmentierung von $f$ entlang $Q$ mit $\gamma$ einen $b$-Fluss $\tilde{f}$.
	Bezüglich $\tilde{f}$ haben dann sowohl alle Vorwärtskanten als auch alle Rückwärtskanten von $C$ eine geringere Auslastung als $q^*$.
	Demnach ist auch $\tilde{f}$ ein auslastungsminimaler $b$-Fluss, dessen Flaschenhalskanten, also Kanten mit Auslastung $q^*$, eine echte Teilmenge von $E'$ sind, da mindestens eine Rückwärtskante in $E'$ enthalten war.
	Dies ist jedoch ein Widerspruch zur Inklusionsminimalität von $E'$.
\end{proof}

Weiter lässt sich nun das folgende fundamentale Theorem zeigen, das den Zusammenhang zwischen der Auslastung von $b$-Flüssen und der von Schnitten darlegt:

\begin{theorem}\label{thm-strong-duality-sparsest-cut-min-flow}
	In einem gerichteten Netzwerk $(V, E, u)$ mit Balancevektor $b\in\R^V$ mit $\sum_{v\in V}b_v = 0$ ist die Auslastung eines $b$-Flusses $f$ mindestens so groß wie die Auslastung eines Schnittes $X$ mit ausgehenden Kanten; das heißt \[\max_{e\in E} \frac{f_e}{u_e} \geq \frac{b(X)}{u(\delta^+(X))}.\]
	Existiert ein $b$-Fluss und ist $E$ nichtleer, so ist die minimale Auslastung eines $b$-Flusses gerade die Auslastung eines dünnsten Schnittes; das bedeutet
	\[
	\min_{\text{$f$ $b$-Fluss}}~\max_{e\in E}\frac{f_e}{u_e} = \max_{\substack{X\subseteq V\\ \delta^+(X)\neq\emptyset}} ~ \frac{b(X)}{u(\delta^+(X))}.
	\]
\end{theorem}
\begin{proof}
	Sei zunächst $f$ ein $b$-Fluss und $X$ ein Schnitt mit $\delta^+(X)\neq\emptyset$.
	Sei $e^*$ eine Kante mit maximaler Auslastung, also eine Kante mit $f_{e^*}/u_{e^*}=\max_{e\in E} f_e / u_e$.
	Für $e^*$ gilt somit $0\geq f_e u_{e^*} - f_{e^*}u_e$ für alle $e\in E$ und man folgere
	\[
	0\geq \frac{\sum_{e\in \delta^+(X)}(f_e u_{e^*} - f_{e^*}u_e)}{u(\delta^+(X)) u_{e^*}} = \frac{f(\delta^+(X))}{u(\delta^+(X))} - \frac{f_{e^*}}{u_{e^*}} \geq \frac{b(X)}{u(\delta^+(X))} - \frac{f_{e^*}}{u_{e^*}},
	\]
	wobei in der letzten Ungleichung $b(X) = f(\delta^+(X)) - f(\delta^-(X))$ eingeht.
	
	Sei nun ein $b$-Fluss $f$ mit minimaler Auslastung $q^*:=\max_{e\in E} f_e/u_e$ gegeben.
	Gesucht ist nun ein Schnitt mit Auslastung $q^*$.
	Ist $b$ der Nullvektor, so ist $q^*=0$ und jeder Schnitt mit ausgehenden Kanten ist ein dünnster Schnitt.
	
	Sonst sei $f$ ein $b$-Fluss minimaler Auslastung $q^* > 0$ mit möglichst wenig maximal ausgelasteten Kanten.
	Sei $e^*=vw$ eine solche maximal ausgelastete Kante und sei $X\subseteq V$ die Menge aller Knoten, die im Residualgraph $G_f$ vom Knoten $v$ erreicht werden können.
	Eine ausgehende Kante $xy\in\delta^+(X)$ muss dann Auslastung $q^*$ haben, da $x$ von $v$ in $G_f$ erreichbar ist und daher $xy$ nicht als Vorwärtskante in $G_f$ erscheinen kann; sonst wäre $y$ auch in $X$.
	Die Auslastung einer eingehenden Kante $xy\in\delta^-(X)$ muss jedoch verschwinden, da $xy$ nicht als Rückwärtskante in $G_f$ auftaucht.
	Außerdem ist $e^*\in \delta^+(X)$, da sonst $w$ von $v$ aus in $G_f$ erreichbar wäre und mit $e^{*\leftarrow}$ einen Kreis in $G_f$ bilden würde, der eine Rückwärtskante maximaler Auslastung benutzt, welchen es nach Lemma~\ref{lemma-no-circle-in-res-graph-inclus-min} nicht geben kann.
	Also ist $\delta^+(X)\neq \emptyset$ und es gilt:
	\[
	\frac{b(X)}{u(\delta^+(X))} = \frac{f(\delta^+(X))}{u(\delta^+(X))} = \sum_{e\in\delta^+(X)} \frac{u_e}{u(\delta^+(X))} q^* = q^*.
	\]
\end{proof}

\begin{corollary}\label{cor-easy-characterization-sparsest-cut}
	Seien $f$ ein $b$-Fluss mit Auslastung $q$ und $X$ ein Schnitt mit $\delta^+(X)\neq \emptyset$ in einem Netzwerk $(V, E, u)$.
	Dann sind die beiden Aussagen äquivalent:
	\begin{enumerate}[label=(\roman*)]
		\item Es sind $X$ ein dünnster Schnitt und $f$ ein $b$-Fluss minimaler Auslastung.
		\item Die Auslastung bezüglich $f$ aller ausgehenden Kanten von $X$ beträgt $q$ und $f$ verschwindet auf allen eingehenden Kanten von $X$.
	\end{enumerate}
\end{corollary}
\begin{proof}
	Aufgrund der Flusserhaltung gilt $b(X) = f(\delta^+(X)) - f(\delta^-(X))$.
	In \[
	\frac{b(X)}{u(\delta^+(X))} \leq \frac{f(\delta^+(X))}{u(\delta^+(X))} \leq \frac{u(\delta^+(X)) q}{u(\delta^+(X))} = q
	\]
	gilt Gleichheit genau dann, wenn $f(\delta^-(X))=0$ und $f_{e}/u_{e} = q$ für alle $e\in\delta^+(X)$ gelten.
	Theorem~\ref{thm-strong-duality-sparsest-cut-min-flow} liefert nun die Behauptung.
\end{proof}

\todo{Insbesondere sind alle inklusionsminimalen dünnsten Schnitte -- gegeben eines minimalen $b$-Flusses -- durch die Methode Residualgraph berechenbar (in sehr geringer polynomieller Zeit, nämlich vermutlich sogar $O(n+m)$ -- Allerdings muss man hier bisschen aufpassen, findet man ausgehend von einer maximal ausgelasteten Kante eine weitere, so muss man (für inklusionsminimalität das Vorgehen von hier zurücksetzen)}

\todo{math-Mode in Überschriften?}
\section{Berechnung auslastungsminimaler $b$-Flüsse}

In diesem Abschnitt soll die Berechnung auslastungsminimaler Flüsse beleuchtet werden.
Aufmerksame Leser konnten bereits im vorherigen Abschnitt einige Analogien auslastungsminimaler $b$-Flüsse zu kostenminimalen $b$-Flüssen erkennen.
Bei der Suche nach kostenminimalen $b$-Flüssen werden die Kanten mit Kosten $c\in\R_{\geq 0}^E$ bewertet und man ist daran interessiert einen $b$-Fluss $f$ zu finden, der den Ausdruck $\sum_{e \in E} c_e f_e$ minimiert und dabei die Kapazitäten der Kanten nicht übersteigt, der also $f_e \leq u_e$ für jede Kante $e$ erfüllt.
Dazu betrachtet man ebenfalls den Residualgraph, allerdings mit einem kleinen Unterschied: Vorwärtskanten werden aufgenommen, wenn deren Auslastung geringer als $1$ statt geringer als die Auslastung des Flusses ist.
Ein $b$-Fluss ist kostenminimal genau dann, wenn der zugehörige, so definierte Residualgraph keine negativen Zyklen hat, also Zyklen $C$ mit $\sum_{e\in C} c_e < 0$ (\todo{Add cite}).

Eine Herangehensweise für das Finden eines kostenminimalen Flusses ist es, ausgehend von einem beliebigen $b$-Fluss iterativ Zyklen im Residualgraph durch Augmentieren zu entfernen.
Verwendet man dabei als Auswahlregel, einen Zyklus mit minimalen mittleren Kantenkosten zu entfernen, so terminiert der sogenannte \emph{Minimum-Mean-Cycle-Cancelling-Algorithmus} mit einem kostenminimalen $b$-Fluss nach $\bigO(nm^2\log n)$ Iterationen mit einer Gesamtlaufzeit von $\bigO(n^2m^3 \log n)$ (siehe \cite[Theoreme~3.9, 3.10]{Goldberg1989}).
Verfolgt man den gleichen Ansatz für die Berechnung eines auslastungsminimalen Flusses, erhält man den nachfolgenden Algorithmus.
\begin{algorithm}
	\caption{Cycle-Cancelling-Algorithmus}
	\label{algorithm-cycle-cancelling}
	\begin{algorithmic}[1]
		\Procedure{CycleCancelling}{$V, E, u, b, s$}
		\State Berechne beliebigen $b$-Fluss $f$
		\While{ein Zyklus $C$ mit Flaschenhalskante existiert in $G_f$}
			\State Augmentiere $f$ entlang $C$ um einen Wert $\gamma$
		\EndWhile
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Sofort ersichtlich ist, dass der Algorithmus im Falle der Terminierung nach Lemma~\ref{lemma-min-flow-criterion} einen auslastungsminimalen $b$-Fluss liefert.
Unklar bleibt, ob der Algorithmus durch eine passende Wahl der Zyklen und der Augmentierungswerte zum Stehen kommt.
Versucht man beispielsweise $\gamma$ so zu wählen, dass die Auslastung des Zyklus $C$, also $\max_{e\in C} f_e / u_e$, nach der Augmentierung möglichst gering ist, kann die Hoffnung auf Terminierung bereits durch das folgendes Beispiel genommen werden:

\begin{example}
	Man betrachte einen Graphen bestehend aus den zwei Knoten $v$ und $w$ sowie den drei Kanten $e_1$, $e_2$ und $e_3$ von $v$ nach $w$.
	Dabei haben alle Kanten die Kapazität $1$ und man suche einen auslastungsminimalen $v$-$w$-Fluss vom Wert $1$.
	Der eindeutige optimale Fluss weist allen drei Kanten den Wert $1/3$ zu.
	
	Startet man beispielsweise mit dem Fluss, der zunächst den gesamten Fluss über Kante $e_1$ schickt, enthält der Residualgraph die Zyklen $\overrightsmallarrow{e_2}\overleftsmallarrow{e_1}$ und $\overrightsmallarrow{e_3}\overleftsmallarrow{e_1}$.
	Wird entlang einer der beiden Zyklen augmentiert -- o.B.d.A. entlang $\overrightsmallarrow{e_2}\overleftsmallarrow{e_1}$ --, so sind $e_1$ und $e_2$ mit Auslastung $1/2$ die Flaschenhalskanten.
	Im nächsten Schritt können die Zyklen $\overrightsmallarrow{e_3}\overleftsmallarrow{e_1}$ und $\overrightsmallarrow{e_3}\overleftsmallarrow{e_2}$ augmentiert werden.
	Auch hier spielt die Wahl aufgrund der Symmetrie keine Rolle und man augmentiere entlang $\overrightsmallarrow{e_3}\overleftsmallarrow{e_2}$, sodass auf der Flaschenhalskante $e_1$ Fluss von Wert $1/2$ und auf $e_2$ und $e_3$ jeweils Fluss von Wert $1/4$ fließt.
	
	\todo{Überprüfe Deutsch}
	Tatsächlich kann man durch beliebige Wahl der Zyklen den auslastungsminimalen Fluss nicht erreichen, da der Fluss zu jeder Zeit auf zwei Kanten $e_i$ und $e_j$ identisch und auf der übrigen Kante $e_k$ unterschiedlich ist, insbesondere beträgt er nie $1/3$ auf allen drei Kanten gleichzeitig: Ist die Kante $e_k$ Flaschenhalskante und wird o.B.d.A. entlang $\overrightsmallarrow{e_i}\overleftsmallarrow{e_k}$ augmentiert, so wird der Wert von $e_i$ und $e_k$ angeglichen und der Wert von $e_k$ echt erhöht.
	Ist die Kante $e_k$ kein Flaschenhals, so wird im nächsten Schritt entlang eines Zyklus', der $e_k$ und o.B.d.A. $e_i$ enthält, augmentiert; der Fluss von $e_k$ und $e_i$ dadurch angeglichen, sodass sich dieser wieder vom Wert von $e_j$ unterscheidet.
\end{example}

\subsection{Berechnung durch Binäre Suche}

Um die Laufzeit des nachfolgenden Algorithmus' präzise analysieren zu können, wird zunächst das zugrundeliegende Berechnungsmodell vorgestellt.
Dabei wird wie in~\cite{Gritzmann2013} eine Variante der Random-Access-Machine (RAM) verwendet.
Diese besteht aus einer Recheneinheit und einem unendlich großen Speicher, dessen Speicherzellen anhand der natürlichen Zahlen adressiert werden und jeweils eine ganze Zahl speichern.
Eine RAM kann ein Programm, also eine endliche Folge von elementaren Instruktionen, ausführen.
Eine solche elementare Instruktion ist entweder eine arithmetische Operation, also eine Addition ($+$), Subtraktion ($-$), Multiplikation ($\cdot$) oder ganzzahlige Division ($\div$), oder ein bedingter Sprung, welcher zunächst zwei Operanden mithilfe eines Vergleichers aus $\{ <, \leq, > \geq, =, \neq \}$ vergleicht und im Wahrheitsfall zu einer bestimmten Instruktion wechselt.
Dabei erlaubt die RAM die Angabe der Operanden durch indirekte Adressierung.
\todo{refine RAM}.


Für die Bestimmung der Laufzeit eines Programms $\mathcal{A}$ wird hier das logarithmische Kostenmaß verwendet, um dem zeitlichen Mehraufwand von beispielsweise der Multiplikation großer Zahlen gerecht zu werden:
Demnach benötigt die Ausführung einer elementaren Instruktion $t$ viele Zeiteinheiten, wobei $t$ die Summe der Kodierungslängen der darin genutzten Zahlen (d.h. Speicheradressen und -werte) ist.
Dabei wird für eine ganze Zahl $z$ die binäre Kodierung verwendet, deren Länge $\size{z} := 1 + \lceil \log_2(\abs{z}+1) \rceil$ ist.
Rationale Zahlen $r$ werden als Tupel zweier ganzer Zahlen $(p,q)$ kodiert, sodass $r = p/q$ gilt.
Dabei wird die Kodierungslänge von $r$ als $\size{r}:= \size{p} + \size{q}$ definiert, wobei $p/q$ bereits die Darstellung von $r$ als vollständig gekürzter Bruch ist.
Entsprechend haben rationale Vektoren $v\in\Q^n$ und Matrizen $A\in\Q^{n\times m}$ Kodierungslängen $\size{v} := \sum_{i=1}^n \size{v_i}$ und $\size{A}:= \sum_{i=1}^n\sum_{j=1}^m \size{a_{i,j}}$.

\begin{proposition}\label{prop-rational-bounds-encoding}
	Es seien $a,b\in\Q$ zwei rationale Zahlen, $v\in Q^n$ ein rationaler Vektor und $A\in\Q^{n\times n}$ eine rationale Matrix.
	Dann gelten:
	\begin{enumerate}[label=(\roman*)]
		\item $\size{ab} \leq \size{a}+\size{b}$,
		\item $\norm{v}_2 \leq 2^{\size{v} - n} - 1$,
		\item $\abs{\det(A)} \leq 2^{\size{A} - n^2}$.
	\end{enumerate}
\end{proposition}
\begin{proof}
	Zunächst zeigt man Aussage $(i)$ für ganze Zahlen $a$ und $b$:
	\begin{align*}
		\size{ab} &= 1+\lceil \log_2(\abs{ab} + 1) \rceil \leq 2+\log_2(\abs{a}\abs{b}+1) \leq 2+\log_2((\abs{a}+1)(\abs{b}+1))\\
		&=2+\log_2(\abs{a} + 1) + \log_2(\abs{b} + 1) = \size{a} + \size{b}.
	\end{align*}
	Es seien nun $a$ und $b$ rationale Zahlen und $p_a/q_a$ und $p_b/q_b$ die vollständig gekürzten Bruchdarstellungen von $a$ und $b$.
	Diesen Fall führt man auf den ganzzahligen zurück: \[
	\size{ab} \leq \size{p_a p_b} + \size{q_a q_b} \leq \size{p_a}+\size{p_b} + \size{q_a} + \size{q_b} = \size{a} + \size{b}.\]
	
	Für jede ganze Zahl $z$ gilt außerdem 
	\[
	\abs{z} = 2^{\log_2(\abs{z} + 1)} - 1 \leq 2^{\lceil\log_2(\abs{z} + 1)\rceil} - 1 = 2^{\size{z} - 1} - 1
	\]
	und daher gilt auch für jede rationale Zahl $r = p/q$ in teilerfremder Darstellung
	\[
	\abs{r} \leq \abs{p} \leq 2^{\size{p} -1} - 1 \leq 2^{\size{r} - 1} -1.
	\]
	
	Des Weiteren folgt mit $\sum_{i=1}^n \abs{v_i}^2 \leq (\sum_{i=1}^n \abs{v_i})^2$ die Ungleichung $\norm{v}_2 \leq \norm{v}_1$.
	Eine verallgemeinerte Version der Bernoulli-Ungleichung besagt, dass für nichtnegative Zahlen $x_1,\dots,x_n$ die Ungleichung $\prod_{i=1}^n (1+x_i) \geq 1 + \sum_{i=1}^n x_i$ gilt.
	Dies ist leicht per Induktion über $n\in\N$ einzusehen:
	Der Induktionsanfang ist klar.
	Der Induktionsschritt folgt ebenfalls sehr schnell:
	\[
	\prod_{i=1}^{n+1} (1+x_i) \geq (1 + \sum_{i=1}^n x_i) x_{n+1} = 1 + x_{n+1} + \sum_{i=1}^n x_i + x_{n+1} \sum_{i=1}^n x_i \geq 1 + \sum_{i=1}^{n+1} x_i.
	\]
	Damit lässt sich Aussage $(ii)$ beweisen:
	\[
		\norm{v}_2 \leq \norm{v}_1 \leq \prod_{i=1}^{n} (1+\abs{v_i}) - 1 \leq \prod_{i=1}^n 2^{\size{v_i} - 1} - 1 = 2^{\size{v} - n} - 1.
	\] 
	
	Für Aussage $(iii)$ benötigt man die Hadamard-Ungleichung: Sind $a^1, \dots, a^n$ die Spaltenvektoren von $A$, so gilt $\abs{\det(A)} \leq  \prod_{i=1}^{n} \norm{a^i}_2$.
	Damit folgere man:
	\[
		\abs{\det(A)} \leq \prod_{i=1}^n (2^{\size{a^i} - n} - 1) \leq 2^{\sum_{i=1}^n \size{a^i} - n^2} = 2^{\size{A} - n^2}.
	\]
\end{proof}

Die Laufzeit eines Programms $\mathcal{A}$ bei Eingabe einer Instanz $\mathcal{I}$ einer Problemklasse $\Pi$ ist dann die Summe der Zeitaufwände der einzelnen Instruktionen, die während der Ausführung des Programms bei Eingabe $\mathcal{I}$ durchlaufen werden.

Es werden einige Grundlagen der Optimierung wiederholt:
\begin{definition}[Lineare Programm in Standardform]
	Ein Optimierungsproblem der Form $\min\{ c^T x \mid x \in P^=(A, b) \}$ mit $c\in\R^n, b\in\R^m, A\in\R^{m\times n}$ und Zulässigkeitsbereich $P^=(A,b):= \{ x\in\R^n \mid Ax = b, x\geq 0 \}$ heißt \emph{lineares Programm in Standardform}.
\end{definition}

\begin{definition}[Ecke konvexer Menge]
	Für eine konvexe Menge $P$ heißt $x\in P$ eine \emph{Ecke von $P$}, falls $x$ das einzige Element des Schnittes von $P$ und einer Stützhyperebene $H:=\{ x\in\R^n \mid d^T x = \delta \}$ mit $d\in\R^n$ und $\delta\in\R$ ist.
\end{definition}

\begin{definition}[Zulässige Basislösung]
Für ein lineares Programm in Standardform mit $P:=P^=(A, b)$ mit $\rank(A) = m$ heißt eine $m$-wertige Teilmenge $B$ von $[n]$ Basis und $N:= [n]\setminus B$ die zugehörige Nichtbasis zu $B$, falls $A_B$ invertierbar ist.
Ein Punkt $x\in P$ ist eine \emph{zulässige Basislösung zur Basis $B$}, falls $x_N$ verschwindet.
In diesem Fall gilt $x_B = A_B^{-1} b$.
\end{definition}

\begin{satz}[{siehe \cite[Satz 5.2.1. (2)]{Jungnickel2008}}]\label{satz-existence-optimality-for-lps}
	Ein lineares Programm in Standardform mit nichtleerem Zulässigkeitsbereich $P:=P^=(A,b)$ und $\rank(A) = m$ hat eine optimale Ecklösung, falls die Zielfunktion $x\mapsto c^T x$ auf $P$ nach unten beschränkt ist.
\end{satz}

\begin{satz}[{siehe \cite[Satz 5.2.3.]{Jungnickel2008}}]\label{satz-ecke-basislsg}
Für ein lineares Programm in Standardform mit nichtleerem Zulässigkeitsbereich $P:=P^=(A,b)$ und $\rank(A) = m$ ist $x\in\R^n$ genau dann eine Ecke von $P$, wenn $x$ eine zulässige Basislösung ist.
\end{satz}

\begin{proposition}\label{prop-rank-obda-m}
	Sei ein nichtleeres Polyeder $P^=(A, b)$ mit $k:=\rank(A)$ und linear unabhängigen Zeilen $a_{i_1},\dots, a_{i_k}$ gegeben.
	Setzt man \[
	\tilde{A}:= (a_{i_1}, \dots, a_{i_k})^T\text{~ und ~}\tilde{b}:= (b_{i_1}, \dots, b_{i_k})^T, \]
	 so hat $\tilde{A}$ Rang $k$ und es gilt $P^=(A,b) = P^=(\tilde{A}, \tilde{b})$.
\end{proposition}
\begin{proof}
	Die Teilmenge $P^=(A,b)\subseteq P^=(\tilde{A}, \tilde{b})$ ist klar:
	Gelten für ein $x\in\R^n_{\geq0}$ alle Ungleichungen von $Ax \leq b$, so erst recht alle der Teilmenge $\tilde{A}x \leq \tilde{b}$.
	
	Da der Zeilenrang von $A$ gerade $k$ ist, existiert für jede Zeile $a_j$ eine Linearkombination $a_j=\sum_{l=1}^k \lambda_l a_{i_l}$ aus den Zeilen in $\tilde{A}$.
	Da $P^=(A,b)$ nichtleer ist, existiert ein $y$ darin, welches die Gleichung
	$b_j = a_j y = \sum_{l=1}^k \lambda_l a_{i_l} y = \sum_{l=1}^k \lambda_l b_{i_l}$ liefert.
	Für alle $x\in P^=(\tilde{A}, \tilde{b})$ gilt also $a_j x = \sum_{l=1}^k \lambda_l a_{i_l} x = \sum_{l=1}^k \lambda_l b_{i_l} = b_j$.
\end{proof}

\begin{lemma}\label{lemma-optimal-value-in-finite-domain}
	Es sei ein lineares Programm in Standardform mit nichtleerem Zu\-lässig\-keits\-bereich $P:= P^=(A,b)$ und ganzzahligen Parametern $A\in \Z^{m\times n}$, $b\in\Z^m$ und $c\in\Z^n$, sodass $x\mapsto c^T x$  auf $P$ nach unten beschränkt ist.
	Es sei $c_{\max}$ der betraglich größte Eintrag in $c$.
	Ist weiter $k$ die Anzahl der Koordinaten, in denen $c$ nicht verschwindet, so liegt der optimale Zielfunktionswert in der endlichen Menge
	\[
	\left\{ \frac{p}{q} ~\middle|~ p\in\Z, q\in\N, \abs{p} \leq k \abs{c_{\max}} 2^{\size{A} + \size{b} -m(n + 1)}, 1\leq q \leq 2^{\size{A}-mn} \right\}.
	\]
\end{lemma}
\begin{proof}
	Es sei $\tilde{A}$ die Teilmatrix von $A$, die $r:=\rank{A}$ linear unabhängige Zeilen von $A$ enthält; $\tilde{b}$ sei der entsprechende Teilvektor von $b$.
	Dann stimmen die Polyeder $P^=(A,b)$ und $P^=(\tilde{A}, \tilde{b})$ nach Proposition~\ref{prop-rank-obda-m} überein.
	Mit den Sätzen~\ref{satz-existence-optimality-for-lps} und~\ref{satz-ecke-basislsg} folgt, dass es eine optimale Basislösung $x^*$ gibt.
	Ist $B$ die Basis von $x^*$, so ist $x^*$ auf den Koordinaten von $B$ gerade $\tilde{A}_B^{-1} \tilde{b}$, sodass die Cramersche Regel die Darstellung $x_i^* = \det(\tilde{A}_B^i) / \det(\tilde{A}_B)$ für jede Koordinate $i\in B$ liefert.
	Dabei ist $\tilde{A}_B^i$ die Matrix, die aus $\tilde{A}_B$ durch Ersetzen der $i$-ten Spalte durch $\tilde{b}$ entsteht.
	Für die Kodierungslänge von $\tilde{A}_B$ ergibt sich die obere Schranke $\size{A} - (mn - r^2)$, da für jeden Eintrag, der in $A$ und nicht in $\tilde{A}_B$ vorkommt, eine Kodierungslänge von mindestens $1$ hinzukommt.
	Entsprechend ist $\size{A} + \size{b} - (mn + m - r^2)$ eine obere Schranke an die Kodierung von $\tilde{A}_B^i$ für alle $i\in B$.
	
	Der optimale Zielfunktionswert hat die Form \[
	c^T x^* = 
	\frac{\sum_{i\in B} c_i \det(A_B^i)}{\det(A_B)}.
	\]
	Der Zähler wird nun mit Proposition~\ref{prop-rational-bounds-encoding} wie folgt abgeschätzt:
	\[
	\left| { \sum_{i\in B} c_i \det(A_B^i) } \right| \leq \sum_{i\in B} \abs{c_{\max}} 2^{\size{\tilde{A}_B^i}- r^2} \leq k \abs{c_{\max}} 2^{\size{A} + \size{b} - m(n+1)}
	\]
	Der Nenner ist betraglich durch $2^{\size{\tilde{A}_B} - r^2}\leq 2^{\size{A} - mn}$ beschränkt, sodass die Aussage folgt.
\end{proof}

Da das Maschinenmodell nur auf Zahlen mit endlicher Kodierung arbeiten kann, wird die Eingabe des Problems zunächst auf rationale Zahlen beschränkt, sodass folgende Problemstellung (MCF) entsteht:

\begin{centering}
	\begin{framed}
		\emph{Minimum Congestion Flow (MCF)} \\[1em]
		\begin{tabular}{rl}
			{\bfseries Input}: &$b$-Fluss-Instanz $(V, E, b\in\Q^V, u \in \Q^E_{>0})$\\
			{\bfseries Output}: &Auslastungsminimaler $b$-Fluss $f$
		\end{tabular}
	\end{framed}
\end{centering}

Ein Algorithmus, der (MCF) löst, soll zudem mit einer Fehlermeldung abbrechen, falls kein $b$-Fluss existiert.
Zunächst wird (MCF) als lineares Optimierungsproblem formuliert.
Dabei minimieren wir die Zahl $q^*$, sodass $b$-Flüsse existieren, deren Auslastung $q^*$ nicht überschreitet:
\begin{equation}\tag{LP}\label{problem-lp-minimal-flow}
\begin{aligned}
& \min q^* \\[1em]
\text{u.d.N.\quad} & \sum_{e\in \delta^+(v)} f_e - \sum_{e\in\delta^-(v)} f_e = b_v & \text{für alle $v\in V$,} \\[1em]
& 0 \leq \frac{f_e}{u_e} \leq q^* & \text{für alle $e\in E$.}
\end{aligned}
\end{equation}

Schnell ist ersichtlich, dass $f$ für eine optimale Lösung $(q^*, f)$ von~(\ref{problem-lp-minimal-flow}) auch ein auslastungsminimaler $b$-Fluss ist: Die $b$-Fluss-Eigenschaft folgt bereits aus der ersten Bedingung und aus der Nichtnegativität von $f_e / u_e$.
Die Auslastungsminimalität von $f$ in~(\ref{problem-lp-minimal-flow}) wird durch die Minimierung der oberen Schranke $q^*$ aller $f_e / u_e$ sichergestellt.
Umgekehrt ist $(c(f), f)$ eine optimale Lösung von~(\ref{problem-lp-minimal-flow}) für einen auslastungsminimalen $b$-Fluss $f$.


\begin{corollary}
	Existiert für eine $b$-Fluss-Instanz $(V, E, b\in\Q^V, u\in\Q^E_{>0})$ ein $b$-Fluss, so ist die Auslastung $q^*$ eines auslastungsminimalen $b$-Flusses enthalten in
	\[
	\left\{ \frac{p}{q} ~\middle|~ p\in\N_0, q\in\N_1, p,q \leq 8^{\size{b} + \size{u} } \right\}.
	\]
\end{corollary}
\begin{proof}
	
Formuliert man~(\ref{problem-lp-minimal-flow}) als lineares Programm in Standardform, so führt man für die Ungleichungen der Form $f_e/u_e \leq q^*$ Schlupfvariablen $y\in\R^E$ ein und erhält:
\newcommand{\nil}{\mathbf{0}}
\newcommand{\one}{\mathbf{1}}
\[
	A = \begin{pmatrix}
		B & \nil_{n\times m} & \nil_{n\times 1} \\
		\one_{m\times m} & \one_{m\times m} & -u
	\end{pmatrix} \in \Q^{(n+m) \times (2m+1)},
	\tilde{b} = \begin{pmatrix}
		b \\
		\nil_{m\times 1}
	\end{pmatrix} \in \Q^{n+m}.
\]
Dabei ist $B$ die Inzidenzmatrix des schleifenfreien Graphen, das heißt, nennt man die Kanten $e_1, \dots, e_m $ und die Knoten $v_1, \dots, v_n$, setzt man  für alle $i\in [n]$ und $j\in [m]$
\[ 
	b_{i,j} := \begin{cases}
		1, & \text{falls $v_i = \head(e_j)$}, \\
		-1, & \text{falls $v_i = \tail(e_j)$},\\
		0, & \text{sonst.}
	\end{cases}
\]
 Die zugehörigen Entscheidungsvariablen sind $(f, y, q^*)^T\in\R_{\geq 0}^{2m+1}$, die Zielfunktion ist definiert durch $x\mapsto c^T x$ mit $c = (\nil_{1\times 2m}, 1)^T$.
 
Multipliziert man nun für $i\in [n]$ die $i$-te Zeile von $A$ und $\tilde{b}$ mit dem Nenner von $b_i$ und für $i\in [m]$ die $(n+i)$-te Zeile mit dem Nenner von $u_i$, so erhält man eine ganzzahlige Matrix $\hat{A}$ und einen ganzzahligen Vektor $\hat{b}$.
Die Kodierungslänge der ersten $n$ Zeilen von $\hat{A}$ beträgt höchstens $2\size{b} + (n-2)m) + nm + n = 2\size{b} + 2nm -2m + n$.
Die restlichen $m$ Zeilen haben eine Kodierungslänge von höchstens $3\size{u} + 2m^2 - 2m$.
Der Vektor $\hat{b}$ hat eine Kodierungslänge von höchstens $\size{b} + m$.

Lemma~\ref{lemma-optimal-value-in-finite-domain} wird nun genutzt, um das Resultat zu folgern.
Dazu werden die folgenden beiden Abschätzungen benötigt:
\begin{align*}
\size{\hat{A}} + \size{\hat{b}} - (n+m)(2m+2) &= \size{\hat{A}} + \size{\hat{b}} - 2mn - 2n - 2m^2 - 2m\\
&\leq 2 \size{b} + 3\size{u} + \size{\hat{b}} - n - 6m \leq 3\size{b} + 3\size{u} -n-5m, \\[1em]
\size{\hat{A}} - (m+n)(2m + 1) &= \size{\hat{A}} - 2m^2 - m - 2mn - n\\
&\leq 2\size{b} + 3\size{u} - 5m.
\end{align*}
\end{proof}

\subsection{Effiziente Suche rationaler Zahlen}

In diesem Abschnitt wird eine effiziente Suche von rationalen Zahlen vorgestellt.
Dabei werden die Ergebnisse von Christos H. Papadimitriou aus~\cite{Papadimitriou1979} erarbeitet.
Die Zielsetzung lautet dabei wie folgt:
Eine nichtnegative, rationale Zahl $x$, deren Zähler und Nenner durch eine Konstante $M$ beschränkt ist, soll nur durch Vergleiche der Form \glqq Ist $x\leq p/q$?\grqq mit $p,q \leq M$ möglichst schnell bestimmt werden.
Dabei werden jedoch mindestens $\theta(\log M)$ Vergleiche benötigt, da bereits das Suchen von $x$ in der Menge $\{ 0/M, 1/M, \dots, M/M \}$ unter der Annahmen, dass $x$ durch einen Bruch mit Nenner $M$ dargestellt werden kann, $\Omega(\log M)$ Vergleiche bedarf.
Der Wunsch ist also ein Verfahren zu finden, das nur $\bigO(\log M)$ viele solcher Vergleiche verwendet.

Dazu werden einige grundlegende Kenntnisse der Farey-Folge benötigt.

\begin{definition}[Farey-Folge]
	Für ein $n> 1$ sei $F_n$ die Menge aller Paare ganzer Zahlen $(x,y)$ mit $0 \leq x \leq y \leq n$, deren größter gemeinsamer Teiler gerade $1$ ist.
	Wegen $\ggT(0,0)= 0$ ist $y$ niemals $0$ und so kann man $F_n$ als die Menge aller Brüche in vollständig gekürzter Darstellung zwischen $0$ und $1$ verstehen, deren Zähler und Nenner durch $n$ beschränkt sind.
	Sortiert man $F_n$ mittels $(i < j \implies x_i^n / y_i^n < x_j^ n/y_j^n)$, so erhält man mit $(x_i^n/y_i^n)_{i\in [f(n)]}$, wobei $f(n)$ die Mächtigkeit von $F_n$ sei, die \emph{Farey-Folge der Ordnung $n$}.
\end{definition}

\begin{example}
	Beispielsweise ist die Farey-Folge der Ordnung $5$ definiert durch:
	\[
		\frac{0}{1}, \frac{1}{5}, \frac{1}{4}, \frac{1}{3}, \frac{2}{5}, \frac{1}{2}, \frac{3}{5}, \frac{2}{3}, \frac{3}{4}, \frac{4}{5}, \frac{1}{1}
	\]
\end{example}