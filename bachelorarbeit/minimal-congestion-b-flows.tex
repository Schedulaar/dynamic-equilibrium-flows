\chapter{Auslastungsminimale $b$-Flüsse}

Eine effiziente Berechnung von Nash-Gleichgewichten erfordert zunächst Verständnis von speziellen Klassen von statischen Flüssen.
Eine wichtige Klasse sind die sogenannten auslastungsminimalen $b$-Flüsse.

\begin{definition}[Auslastungsminimaler $b$-Fluss]
	Sei ein $b$-Fluss $f$ auf einem Netzwerk ohne Schleifen mit Kapazitäten $u\in\R_{>0}^E$ gegeben.
	Dann heißt $f_e/u_e$ die \emph{Auslastung der Kante $e$ durch $f$} und die maximale Kantenauslastung $c(f):=\max_{e\in E} f_e/u_e$ bezeichnet die \emph{Auslastung des Flusses $f$}.
	Eine Kante mit Auslastung $c(f)$ wird auch als \emph{Flaschenhalskante} (engl. bottleneck edge) bezeichnet.
	Ein $b$-Fluss mit minimaler Auslastung wird dann \emph{auslastungsminimaler $b$-Fluss} genannt.
\end{definition}

In diesem Kapitel wird ein Optimalitätskriterium und ein effizienter Algorithmus zur Berechnung solcher auslastungsminimaler $b$-Flüsse vorgestellt.
Dabei wird angenommen, dass der Graph keine Schleifen besitzt, da diese bei der Berechnung auslastungsminimaler $b$-Flüsse ignoriert werden können.

\section{Optimalitätskriterium auslastungsminimaler $b$-Flüsse}

In diesem Abschnitt wird ein hinreichendes sowie notwendiges Kriterium auslastungsminimaler $b$-Flüsse erarbeitet.

Ähnlich zum wohlbekannten Max-Flow-Min-Cut-Theorem von Ford und Fulkerson betrachtet man dabei ein duales Problem, das die Auslastung von Schnitten involviert.

\begin{definition}[Schnitt]
	In einem gerichteten Netzwerk $(V, E, u)$ heißt eine Teilmenge $X\subseteq V$ \emph{Schnitt}, wobei die aus $X$ ausgehenden Kanten mit $\delta^+(X)$ und die in $X$ eingehenden Kanten mit $\delta^-(X)$ bezeichnet werden.
	
	Sind zusätzlich Knotenbalancen $b\in\R^V$ mit $\sum_{v\in V} b_v = 0$ gegeben und ist $\delta^+(X)$ nichtleer, so bezeichne $b(X) / u(\delta^+(X))$ die \emph{Auslastung des Schnittes $X$}.
	Dabei ist $b(X)$ bzw. $u(E')$ eine Kurzschreibweise für $\sum_{v\in X} b_v$ bzw. $\sum_{e\in E'} u_e$.
	Existiert ein Schnitt, dessen Auslastung maximal ist, so nennt man ihn einen \emph{dünnsten Schnitt}.
\end{definition}
Man bemerke, dass ein dünnster Schnitt existiert, wenn die Kantenmenge $E$ nichtleer ist.
Man kann leicht erkennen, dass die Auslastung eines Schnittes höchstens so groß ist wie die eines $b$-Flusses.
Dies ist auch anschaulich klar, da das Angebot $b(X) > 0$ eines Schnittes $X$ im besten Fall gleichmäßig auf die Kapazitäten aller ausgehenden Kanten des Schnittes verteilt wird.

\begin{theorem}[Schwache Dualität]\label{thm-weak-duality-min-con-flow}
 	In einem gerichteten Netzwerk $(V, E, u)$ mit Balancevektor $b\in\R^V$ mit $\sum_{v\in V}b_v = 0$ ist die Auslastung eines $b$-Flusses $f$ mindestens so groß wie die Auslastung eines Schnittes $X$ mit ausgehenden Kanten; das heißt \[\max_{e\in E} \frac{f_e}{u_e} \geq \frac{b(X)}{u(\delta^+(X))}.\]
\end{theorem}
\begin{proof}
	Sei $e^*$ eine Flaschenhalskante bzgl. $f$.
	Für diese gilt $0\geq f_e u_{e^*} - f_{e^*}u_e$ für alle Kanten $e\in E$ und man folgere
	\[
	0\geq \frac{\sum_{e\in \delta^+(X)}(f_e u_{e^*} - f_{e^*}u_e)}{u(\delta^+(X)) u_{e^*}} = \frac{f(\delta^+(X))}{u(\delta^+(X))} - \frac{f_{e^*}}{u_{e^*}} \geq \frac{b(X)}{u(\delta^+(X))} - \frac{f_{e^*}}{u_{e^*}},
	\]
	wobei in der letzten Ungleichung $b(X) = f(\delta^+(X)) - f(\delta^-(X))$ eingeht.
\end{proof}

Dieser Abschnitt soll nun dazu dienen, auch die starke Dualität zu zeigen.
Zunächst betrachte man das folgende Beispiel.

\begin{example}\label{example-min-con-flow}
	\begin{figure}
				\newcommand{\newnode}[4]{\node[lul] (#1) at #2 {#3 \\[0.5em] #4};}
		\centering
		\begin{subfigure}{\textwidth}
			\centering
			\begin{tikzpicture}[lul/.style={draw,
				ellipse,
				align=center,
				inner sep=0pt,
				outer sep=4pt,
				text width=7mm,
				minimum height=1.5cm
			},
			scale=1]
			
			\newnode{a}{(0,4)}{$a$}{$-3$}
			\newnode{b}{(4,4)}{$b$}{$-2$}
			\newnode{c}{(8,4)}{$c$}{$-2$}
			\newnode{d}{(12,4)}{$d$}{$-1$}
			\newnode{e}{(2,2)}{$e$}{$1$}
			\newnode{f}{(6,2)}{$f$}{$5$}
			\newnode{g}{(10,2)}{$g$}{$-1$}
			\newnode{h}{(4,0)}{$h$}{$2$}
			\newnode{i}{(8,0)}{$i$}{$1$}
			
			\begin{scope}[-Latex]
			\path [-Latex] (a) edge node[above right] {$1$} (e);
			\path [-Latex] (b) edge node[above] {$4$} (a);
			\path [-Latex] (c) edge node[above] {$0$} (b);
			\path [-Latex] (c) edge node[above right] {$1$} (g);
			\path [-Latex] (c) edge node[above] {$1$} (d);
			\path [-Latex] (d) edge node[above left] {$0$} (g);
			\path [-Latex] (e) edge node[above left] {$2$} (b);
			\path [-Latex] (e) edge node[above right] {$0$} (h);
			\path [-Latex] (f) edge node[above right] {$4$} (b);
			\path [-Latex] (f) edge node[above left] {$4$} (c);
			\path [-Latex] (f) edge node[above right] {$1$} (i);
			\path [-Latex] (g) edge node[above left] {$0$} (i);
			\path [-Latex] (h) edge node[above left] {$4$} (f);
			\path [-Latex] (i) edge node[above] {$2$} (h);
			\end{scope}
			\end{tikzpicture}
		\end{subfigure}
		\caption{Ein auslastungsminimaler $b$-Fluss. Die Balancen stehen mit einem Bezeichner in den Knoten, der Flusswert auf den Kanten. Alle Kanten haben Kapazität $1$.}
		\label{figure-min-con-example}
	\end{figure}
	Man betrachte den $b$-Fluss $x$ in Abbildung~\ref{figure-min-con-example}.
	Die maximale Kantenauslastung durch $x$ ist $4$, welche auf den Kanten $(b,a), (f,b),(f,c)$ und $(h,f)$ angenommen.
	Bei der Frage, ob $x$ schon ein auslastungsminimaler $b$-Fluss ist, kann man nun die schwache Dualität ausnutzen:
	
	Der Schnitt $Y := \{ c, d, g \}$ hat nur eine einzige eingehende Kante, nämlich $(f,c)$.
	Außerdem hat $Y$ eine Nachfrage von $-4$.
	Entsprechend muss auf der Kante $(f,c)$ mindestens Fluss im Wert von $4$ fließen.
	In der Form von Theorem~\ref{thm-weak-duality-min-con-flow} würde man argumentieren mit $X:= V\setminus Y$, für das $b(X) = 4$ und $u(\delta^+(X)) = 1$ gilt.
	Dann muss die Auslastung eines $b$-Flusses mindestens $4/1=4$ sein.
	Da die Auslastung von $x$ ebenfalls $4$ beträgt, ist $x$ auslastungsminimal.
	Daher ist auch $X$ ein dünnster Schnitt.
\end{example}
\begin{definition}[Doppelgraph]
	Der Doppelgraph $G^\leftrightarrow$ eines Graphen $G=(V,E)$ ist das Paar $(V, \overrightsmallarrow{E}\cup \overleftsmallarrow{E})$, wobei $\overrightsmallarrow{E}:=\{ \overrightsmallarrow{e} \mid e\in E \}$ die Menge der Vorwärtskanten, die die Richtung der Ursprungskante beibehalten, und $\overleftsmallarrow{E}:=\{ \overleftsmallarrow{e} \mid e\in E \}$ die Menge der Rückswärtskanten, die die Richtung der Ursprungskante umkehren, sind.
\end{definition}
\begin{definition}[Residualgraph eines $b$-Flusses]
	Sei ein $b$-Fluss $f$ auf einem Netzwerk $(V, E)$ mit Kapazitäten $u\in\R^E_{>0}$ gegeben.
	Der \emph{Residualgraph von $G$ bezüglich $f$} ist definiert durch $G_f := (V, E_f)$ mit \[
	E_f := \{ \overrightsmallarrow{e}\in \overrightsmallarrow{E} \mid f_e/u_e < c(f) \} \cup \{ \overleftsmallarrow{e} \in \overleftsmallarrow{E} \mid f_e/u_e > 0 \}.
	\]
\end{definition}

Im Residualgraph eines $b$-Flusses $f$ wird eine Kante also in beide Richtungen erstellt, falls die Auslastung durch $f$ echt zwischen $0$ und $q^*$ liegt. Fließt kein Fluss auf der Kante, so gibt es nur die Vorwärtskante, und handelt es sich um eine Flaschenhalskante, so existiert nur die Rückwärtskante.
Abbildung~\todo{Add ref} zeigt den Residualgraphen für Beispiel~\ref{example-min-con-flow}.

Zunächst wird ein hinreichendes Optimalitätskriterium für $b$-Flüsse vorgestellt:

\begin{lemma}\label{lemma-min-flow-criterion}
	Ist $f$ ein $b$-Fluss in $(V, E, u)$, dessen Residualgraph keine gerichteten Kreise besitzt, die eine Flaschenhalskante als Rückwärtskante benutzen, so ist $f$ auslastungsminimal.
	Ist $f'$ ein weiterer auslastungsminimaler Fluss, so sind die Flaschenhalskanten $E^*$ von $f$ auch Flaschenhalskanten von $f'$.

	Man nennt $E^*$ die \emph{minimale Menge der Flaschenhalskanten bzgl. $(V, E, u, b)$.}
\end{lemma}

Um diese Aussage zu zeigen, benötigt man folgende Hilfsproposition:

\begin{proposition}\label{prop-difference-b-flows-stream}
	Für zwei $b$-Flüsse $f$, $f'$ mit $c(f) \geq c(f')$ ist $f'\Delta f := g\in \R_{\geq0}^{E^\leftrightarrow}$, definiert durch
	\begin{align*}
	g_{\overrightsmallarrow{e}} := \max\{ 0, f_e' - f_e \} \text{~~~und~~~}
	g_{\overleftsmallarrow{e}} := \max\{ 0, f_e - f_e' \} \text{~~~für $e\in E$},
	\end{align*}
	eine Strömung auf $G^\leftrightarrow$, die auf $E^\leftrightarrow \setminus E_f$ verschwindet.
\end{proposition}
\begin{proof}
	Eine Strömung ist eine Kantenbewertung, die in jedem Knoten Flusserhaltung erhält.
	Man zeige also $g(\delta^+_{G^\leftrightarrow}(v)) - g(\delta^-_{G^\leftrightarrow}(v)) = 0$ für alle Knoten $v\in V$.
	Durch Fallunterscheidung erkenne man $g_{\overrightsmallarrow{e}} - g_{\overleftsmallarrow{e}} = f_e' - f_e$ für alle $e\in E$ und man folgere:
	\begin{align*}
	g(\delta^+_{G^\leftrightarrow}(v)) - g(\delta^-_{G^\leftrightarrow}(v))
	&= \left( \sum_{e\in\delta^+_G(v)} g_{\overrightsmallarrow{e}} +  \sum_{e\in\delta^-_G(v)} g_{\overleftsmallarrow{e}} \right)
	- \left(\sum_{e\in\delta^-_G(v)} g_{\overrightsmallarrow{e}} + \sum_{e\in\delta^+_G(v)} g_{\overleftsmallarrow{e}} \right) \\
	&= \sum_{e\in\delta^+_G(v)} (g_{\overrightsmallarrow{e}} - g_{\overleftsmallarrow{e}}) - \sum_{e\in\delta^-_G(v)} (g_{\overrightsmallarrow{e}} - g_{\overleftsmallarrow{e}})\\
	&= \sum_{e\in\delta^+_G(v)} (f_e' - f_e) - \sum_{e\in\delta^-_G(v)} (f_e' - f_e) = b_v - b_v = 0.
	\end{align*}
	Es bleibt also zu zeigen, dass $g$ auf $E^\leftrightarrow \setminus E_f$ verschwindet.
	Sei zunächst eine Vorwärtskante $\overrightsmallarrow{e}$ mit $f_{e}/u_{e} = c(f)$ gegeben.
	Dann gilt nach Voraussetzung auch $f_{e}/u_{e} = c(f) \geq c(f') \geq f'_{e}/u_{e}$, wodurch $g_{\overrightsmallarrow{e}}= 0$ folgt.
	Für eine Rückwärtskante $\overleftsmallarrow{e}$ mit $f_e = 0$ folgt $g_{\overleftsmallarrow{e}} = 0$ direkt.
\end{proof}

Insbesondere existiert für solche Strömungen $f'\Delta f$ eine Dekomposition in Zyklen.
Diese Eigenschaft wird im folgenden Beweis ausgenutzt:

\begin{proof}[Beweis von Lemma~\ref{lemma-min-flow-criterion}]
	Sei $f$ ein $b$-Fluss, dessen Residualgraph keine gerichteten Kreise mit einer Flaschenhalskante besitzt, und sei $e$ eine beliebige Flaschenhalskante von $f$.
	Sei $f'$ ein $b$-Fluss minimaler Auslastung.
	Angenommen es gebe eine Flaschenhalskante $e$ von $f$ mit $f'_e/u_e < f_e/u_e$.
	Die Strömung $g:= f'\Delta f$ besitzt nach Proposition~\ref{prop-difference-b-flows-stream} eine Dekomposition in Zyklen $g = \lambda_1 \cdot C_1 +\dots + \lambda_k \cdot C_k$ mit $\lambda_i > 0$ für $i\in[k]$.
	Da $g_{\overleftsmallarrow{e}}$ positiv ist, gibt es einen Zyklus $C_i$, der ${\overleftsmallarrow{e}}$ enthält.
	Da $g$ außerdem nur auf $E_f$ verläuft, enthält $E_f$ also den Zyklus $C_i$, der die Flaschenhalskante $e$ benutzt, was im Widerspruch zur Voraussetzung steht.
	Also muss bereits $f'_e / u_e \geq f_e / u_e$ gelten, wodurch die Behauptung folgt.
\end{proof}



\begin{definition}[Zusammenhangsgraph]
	Für einen Graphen $G = (V,E)$ sei die Relation ${\sim} \subseteq V\times V$ die Äquivalenzrelation gegeben durch \[
	v\sim w :\Leftrightarrow \text{$v$ ist von $w$ in $G$ erreichbar und $w$ ist von $v$ in $G$ erreichbar}.
	\]
	Dann nennt man den azyklischen Graphen $G^\sim:=(V^\sim, E^\sim)$ den \emph{Zusammenhangsgraphen von $G$}, wobei die Knoten $V^\sim$ die Menge der Äquivalenzklassen -- also die Menge der \emph{(starken) Zusammenhangskomponenten} -- sind und eine Kante $xy$ in $E^\sim$ genau dann existiert, wenn $x\neq y$ gilt und es eine Kante $vw$ in $E$ gibt, sodass $v$ in der Zusammenhangskomponente $x$ und $w$ in der Zusammenhangskomponente $y$ liegen.
\end{definition}

Man sieht schnell, dass ein Knoten $w$ genau dann von einem anderen Knoten $v$ erreicht werden kann, wenn die Äquivalenzklasse von $w$ im Zusammenhangsgraph von der Äquivalenzklasse von $v$ erreicht werden kann.

\begin{proposition}\label{prop-augment-min-con-flow-with-circuit}
	Es sei $f$ ein $b$-Fluss minimaler Auslastung $q^*>0$ mit Flaschenhalskanten $E'$.
	Weiter seien $C$ ein Kreis im Residualgraph $G_f$ und $E_C'$ die Menge der Flaschenhalskanten von $f$, die $C$ als Rückwärtskanten verwendet.
	Dann existiert ein auslastungsminimaler $b$-Fluss $\tilde{f}$ mit Flaschenhalskanten $E' \setminus E_C'$, für den der Zusammenhangsgraph von $G_{\tilde{f}}$ mit dem Zusammenhangsgraph von $G_f$ übereinstimmt.
\end{proposition}
\begin{proof}
	\newcommand{\VK}{\text{VK}}
	\newcommand{\RK}{\text{RK}}
	Es sei $q^* > 0$ die Auslastung von $f$, $C_\VK$ die Menge der Vorwärtskanten und $C_\RK$ die Menge der Rückwärtskanten in $C$.
	Es seien $C^1,\dots, C^k$ elementare Kreise, die die Kanten von $C$ überdecken, die also $\bigcup_{i\in [k]} E(C^i) = E(C)$ erfüllen.
	
	Man setze $\gamma_\VK := \min_{\overrightsmallarrow{e}\in C_\VK} q^*u_e - f_e > 0$ als die minimale Flussmenge, die man jeder Kante in $C_\VK$ zufügen müsste, sodass mindestens eine Kante darin mindestens Auslastung $q^*$ erhält.
	Weiter sei $\gamma_\RK := \min_{\overleftsmallarrow{e}\in C_\RK} f_e > 0$ die minimale Flussmenge der Rückwärtskanten in $C$.
	Wählt man nun ein $\gamma \in (0, \min\{ \gamma_\VK, \gamma_\RK  \})$, so erhält man durch $(\gamma/k)$-wertige Augmentierung von $f$ entlang jedes Kreises $C^i$ einen $b$-Fluss $\tilde{f}$.
	
	Bezüglich $\tilde{f}$ haben dann sowohl alle Vorwärtskanten als auch alle Rückwärtskanten von $C$ eine geringere Auslastung als $q^*$.
	Demnach ist auch $\tilde{f}$ ein auslastungsminimaler $b$-Fluss, dessen Flaschenhalskanten gerade die Menge $E_1 \setminus E_C$ sind.
	
	Außerdem sind die Kanten des Residualgraph von $\tilde{f}$ gegeben durch die Kanten von $G_f$ und zusätzlich den Kanten $\overrightsmallarrow{e}$ für Flaschenhalskanten $\overleftsmallarrow{e}\in C_{\RK}$ bzgl. $f$ in $C$ sowie Kanten $\overleftsmallarrow{e}$ für Kanten $e\in C_{\VK}$ mit $f_e = 0$.
	Diese zusätzlichen Kanten können jedoch nicht dafür sorgen, dass verschiedene Zusammenhangskomponenten von $G_f$ zu einer Zusammenhangskomponente von $G_{\tilde{f}}$ verschmelzen, denn diese liegen in umgekehrter Richtung auf einem Kreis, der sowohl in $G_f$ als auch in $G_{\tilde{f}}$ auftaucht.
	Daher sind die Zusammenhangsgraphen von $G_f$ und $G_{\tilde{f
	}}$ gleich.
\end{proof}

\begin{figure}
	\newcommand{\newnode}[4]{\node[lul] (#1) at #2 {#3 \\[0.5em] #4};}
	\centering
	\begin{subfigure}{\textwidth}
		\centering
		\tikzset{auto rotate/.style={auto=right,->,
				to path={let \p1=(\tikztostart),\p2=(\tikztotarget),
					\n1={atan2(\y2-\y1,\x2-\x1)},\n2={\n1-10},\n3={\n1+190}
					in (\tikztostart.\n2) -- (\tikztotarget.\n3) \tikztonodes}}}
		\begin{tikzpicture}[lul/.style={draw,
			ellipse,
			fill=white,
			align=center,
			inner sep=0pt,
			outer sep=4pt,
			text width=7mm,
			minimum height=1.5cm
		},
		scale=1]
		
		\fill[fill=lightgray, rounded corners=1cm] (-2, 5) -- (2,0) -- (6, 5) -- cycle;
		\fill[fill=lightgray, rounded corners=1cm] (2,-1) -- (6,4) -- (10, -1) -- cycle;
		\fill[fill=lightgray, rounded corners=1cm] (6, 5) -- (10,0) -- (14, 5) -- cycle;
		
		\node at (2,5.5) {$Z_1$};
		\node at (6,-1.5) {$Z_2$};
		\node at (10,5.5) {$Z_3$};
		
		\newnode{a}{(0,4)}{$a$}{$-3$}
		\newnode{b}{(4,4)}{$b$}{$-2$}
		\newnode{c}{(8,4)}{$c$}{$-2$}
		\newnode{d}{(12,4)}{$d$}{$-1$}
		\newnode{e}{(2,2)}{$e$}{$1$}
		\newnode{f}{(6,2)}{$f$}{$5$}
		\newnode{g}{(10,2)}{$g$}{$-1$}
		\newnode{h}{(4,0)}{$h$}{$2$}
		\newnode{i}{(8,0)}{$i$}{$1$}
		
		\begin{scope}[-Latex]
		\path [-Latex] (a) edge[auto rotate] node[above right] {} (e);
		\path [-Latex] (e) edge[auto rotate, dashed] node[above right] {} (a);
		\path [-Latex] (a) edge[auto rotate, dashed] node[above] {} (b);
		\path [-Latex] (c) edge[auto rotate] node[above] {} (b);
		\path [-Latex] (c) edge[auto rotate] node[above right] {} (g);
		\path [-Latex] (g) edge[auto rotate, dashed] node[above right] {} (c);
		\path [-Latex] (c) edge[auto rotate] node[above] {} (d);
		\path [-Latex] (d) edge[auto rotate, dashed] node[above] {} (c);
		\path [-Latex] (d) edge[auto rotate] node[above left] {} (g);
		\path [-Latex] (e) edge[auto rotate] node[above left] {} (b);
		\path [-Latex] (b) edge[auto rotate, dashed] node[above left] {} (e);
		\path [-Latex] (e) edge[auto rotate] node[above right] {} (h);
		\path [-Latex] (b) edge[auto rotate, dashed] node[above right] {} (f);
		\path [-Latex] (c) edge[auto rotate, dashed] node[above left] {} (f);
		\path [-Latex] (f) edge[auto rotate] node[above right] {} (i);
		\path [-Latex] (i) edge[auto rotate, dashed] node[above right] {} (f);
		\path [-Latex] (g) edge[auto rotate] node[above left] {} (i);
		\path [-Latex] (f) edge[auto rotate, dashed] node[above left] {} (h);
		\path [-Latex] (i) edge[auto rotate] node[above] {} (h);
		\path [-Latex] (h) edge[auto rotate, dashed] node[above] {} (i);
		\end{scope}
		
		\end{tikzpicture}
	\end{subfigure}
	\caption{Der Residualgraph vom Fluss aus Abbildung~\ref{figure-min-con-example}. Vorwärtskanten sind durchgezogen, Rückwärtskanten gestrichelt. Zusammenhangskomponenten sind grau hinterlegt.}
\end{figure}

Das nächste Lemma bildet in gewisser Weise die Rückrichtung von Lemma~\ref{lemma-min-flow-criterion}:

\begin{lemma}\label{lemma-no-circle-in-res-graph-inclus-min}
	Sei $q^*$ die minimale Auslastung eines $b$-Flusses $f$ im Netzwerk $(V, E, u)$.
	Ist die Menge $E^*$ der Flaschenhalskanten von $f$ minimal, so enthält der Residualgraph $G_f$ keine gerichteten Kreise, die eine Flaschenhals\-kante als Rückwärts\-kante benutzen.
\end{lemma}
\begin{proof}
	Ist $q^* = 0$, so ist $f$ bereits der Nullfluss und $G_f$ ist ein kantenloser Graph.
	Man betrachte also $q^* > 0$.
	Angenommen, es existiere ein Kreis $C$, der mindestens eine Flaschenhalskante als Rückwärtskante enthält.
	Dann existiert nach Proposition~\ref{prop-augment-min-con-flow-with-circuit} ein auslastungsminimaler $b$-Fluss ohne die Flaschenhalskanten in $C$.
	Dies ist jedoch ein Widerspruch zur Minimalität von $E^*$.
\end{proof}

\todo{Irgendwo anmerken, was augmentieren heißt.}

\todo{Change this to: Für jeden auslastungsminimalen $b$-Fluss hat der Residualgraph den gleichen Zusammenhangsgraphen. Kanten zwischen den Zusammenhangskomponenten in $G_f$ sind Rückwärtskanten der minimalen Menge an Flaschenhalskanten sowie Vorwärtskanten, die unter jedem auslastungsminimalen $b$-Fluss verschwinden.}
\begin{proposition}\label{prop-min-bottlenecks-between-strong-comps}
	Sei $f$ ein $b$-Fluss minimaler Auslastung $q^*>0$ im Netzwerk $(V, E, u)$.
	Dann ist die Menge $E^*$ der Flaschenhalskanten von $f$, die als Rückwärtskanten zwischen Zusammenhangskomponenten von $G_f$ verlaufen, die minimale Menge an Flaschenhalskanten.
	
	Außerdem stimmt der Zusammenhangsgraph von $G_f$ mit dem des Residualgraphen eines jeden auslastungsminimalen $b$-Flusses mit Flaschenhalskanten $E'$ überein.
\end{proposition}
\begin{proof}
	Es seien $Z_1,\dots, Z_k$ die Zusammenhangskomponenten des Residualgraphs $G_f$.
	Für alle $i\in [k]$ sei $C_i$ ein Kreis, der alle Kanten, die innerhalb $Z_i$ verlaufen, abläuft.
	Dann existiert nach Proposition~\ref{prop-augment-min-con-flow-with-circuit} ein auslastungsminimaler $b$-Fluss $\tilde{f}$, dessen Residualgraph den gleichen Zusammenhangsgraph hat wie der von $f$, für den aber innerhalb der Zusammenhangskomponenten keine Flaschenhalskanten als Rückwärtskanten vorkommen.
	Zwischen den Zusammenhangskomponenten haben $f$ und $\tilde{f}$ jedoch die gleichen Flaschenhalskanten.
	
	Dementsprechend ist im Residualgraph $G_{\tilde{f}}$ kein Kreis, der eine Flaschenhalskante von $\tilde{f}$ als Rückwärtskante verwendet, sodass $\tilde{f}$ nach Lemma~\ref{lemma-min-flow-criterion} die minimale Menge an Flaschenhalskanten besitzt.
	Dies sind gerade die Flaschenhalskanten von $f$ zwischen den Zusammenhangskomponenten.
	
	Außerdem hat jeder auslastungsminimale $b$-Fluss $g$ zumindest die Flaschenhalskanten $E^*$.
	Aus $g$ erhalte man wie oben den auslastungsminimalen $b$-Fluss $\tilde{g}$, für den $G_{\tilde{g}}$ den gleichen Zusammenhangsgraphen wie $G_g$ hat.
	Seien $v$ und $w$ in der gleichen Zusammenhangskomponente von $G_{\tilde{f}}$.
	Dann existiert ein gerichteter Kreis $C$ in $G_f$, der $v$ und $w$ enthält, welcher keine Rückwärtskanten von $E^*$ benutzt.
	
\end{proof}

\begin{lemma}\label{lemma-calc-sparsest-cut}
	Sei $f$ ein $b$-Fluss minimaler Auslastung $q^*$ im Netzwerk $(V, E, u)$ mit nichtleerer Kantenmenge $E$.
	Dann kann in $\bigO(n+m)$ Zeit ein dünnster Schnitt mit Auslastung $q^*$ berechnet werden.
	Dabei seien $n$ die Anzahl der Knoten und $m$ die Anzahl der Kanten.
\end{lemma}
\begin{proof}
	Ist $q^* = 0$, so ist $b$ bereits der Nullvektor und es kann jede einelementige Knotenmenge mit mindestens einer ausgehenden Kante verwendet werden.
	Sonst berechne man in~$\bigO(n+m)$ Zeit zum Beispiel mit Tarjan's Algorithmus (siehe \todo{add cite}) die starken Zusammenhangskomponenten $Z_1, \dots, Z_k$ des Residualgraphen $G_f$.
	Nach Proposition~\ref{prop-min-bottlenecks-between-strong-comps} sind die Flaschenhalskanten von $f$, die als Rückwärtskanten zwischen den Zusammenhangskomponenten von $G_f$ verlaufen, gerade die minimale Menge $E'$ der Flaschenhalskanten.
	In $\bigO(m)$ Zeit identifiziere man eine solche Kante $\overleftsmallarrow{vw}$ mit $vw\in E'$ und sammle alle Knoten, die in $G_f$ von $v$ aus erreichbar sind, in der Menge $X$.
	
	Eine ausgehende Kante $xy\in\delta^+_G(X)$ muss dann bzgl. $f$ Auslastung $q^*$ haben, da $x$ von $v$ in $G_{f}$ erreichbar ist und daher $xy$ nicht als Vorwärtskante in $G_f$ erscheinen kann; sonst wäre $y$ auch in $X$.
	Die Auslastung einer eingehenden Kante $xy\in\delta^-_G(X)$ bzgl. $f$ muss jedoch verschwinden, da $xy$ nicht als Rückwärtskante in $G_f$ auftaucht.
	
	Nach Proposition~\ref{prop-min-bottlenecks-between-strong-comps} existiert ein auslastungsminimaler $b$-Fluss $\tilde{f}$ mit Flaschenhalskanten $E'$, dessen Residualgraph $G_{\tilde{f}}$ den gleichen Zusammenhangsgraph hat wie $G_f$.
	Die Knoten in $X$ sind also gerade alle Knoten, die in $G_{\tilde{f}}$ von $v$ aus erreichbar sind.
	Dann ist $vw$ eine ausgehende Kante von $X$, da sonst $w$ von $v$ aus in $G_{\tilde{f}}$ erreichbar wäre und mit $\overleftsmallarrow{vw}$ einen Kreis in $G_{\tilde{f}}$ bilden würde, der eine Rückwärtskante maximaler Auslastung benutzt, welchen es nach Lemma~\ref{lemma-no-circle-in-res-graph-inclus-min} nicht geben kann.
	Also ist $\delta^+_G(X)\neq \emptyset$ und es gilt:
	\[
	\frac{b(X)}{u(\delta^+_G(X))} = \frac{f(\delta^+_G(X))}{u(\delta^+(X))} = \sum_{e\in\delta^+(X)} \frac{u_e}{u(\delta^+(X))} q^* = q^*.
	\]
	Aufgrund der schwachen Dualität ist $X$ nach Theorem~\ref{thm-weak-duality-min-con-flow} ein dünnster Schnitt.
\end{proof}

Nun lässt sich das folgende wichtige Theorem zeigen, das den Zusammenhang zwischen der Auslastung von $b$-Flüssen und der von Schnitten darlegt:

\begin{theorem}\label{thm-strong-duality-sparsest-cut-min-flow}
	Existiert in einem gerichteten Netzwerk $(V, E, u)$ mit Balancevektor $b\in\R^V$ ein $b$-Fluss und ist $E$ nichtleer, so ist die minimale Auslastung eines $b$-Flusses gerade die Auslastung eines dünnsten Schnittes; das bedeutet
	\[
	\min_{\text{$f$ $b$-Fluss}}~\max_{e\in E}\frac{f_e}{u_e} = \max_{\substack{X\subseteq V\\ \delta^+(X)\neq\emptyset}} ~ \frac{b(X)}{u(\delta^+(X))}.
	\]
\end{theorem}
\begin{proof}
	Die Existenz eines auslastungsminimalen Flusses und eines dünnsten Schnittes folgt aus den Voraussetzungen.
	Schwache Dualität nach Theorem~\ref{thm-weak-duality-min-con-flow} liefert, dass jeder Schnitt höchstens die Auslastung eines auslastungsminimalen $b$-Flusses hat.
	Lemma~\ref{lemma-calc-sparsest-cut} zeigt, dass diese untere Schranke auch tatsächlich durch einen Schnitt angenommen wird.
\end{proof}

\begin{corollary}\label{cor-easy-characterization-sparsest-cut}
	Seien $f$ ein $b$-Fluss mit Auslastung $q$ und $X$ ein Schnitt mit $\delta^+(X)\neq \emptyset$ in einem Netzwerk $(V, E, u)$.
	Dann sind die beiden Aussagen äquivalent:
	\begin{enumerate}[label=(\roman*)]
		\item Es sind $X$ ein dünnster Schnitt und $f$ ein $b$-Fluss minimaler Auslastung.
		\item Die Auslastung bezüglich $f$ aller ausgehenden Kanten von $X$ beträgt $q$ und $f$ verschwindet auf allen eingehenden Kanten von $X$.
	\end{enumerate}
\end{corollary}
\begin{proof}
	Aufgrund der Flusserhaltung gilt $b(X) = f(\delta^+(X)) - f(\delta^-(X))$.
	In \[
	\frac{b(X)}{u(\delta^+(X))} \leq \frac{f(\delta^+(X))}{u(\delta^+(X))} \leq \frac{u(\delta^+(X)) q}{u(\delta^+(X))} = q
	\]
	gilt Gleichheit genau dann, wenn $f(\delta^-(X))=0$ und $f_{e}/u_{e} = q$ für alle $e\in\delta^+(X)$ gelten.
	Theorem~\ref{thm-strong-duality-sparsest-cut-min-flow} liefert nun die Behauptung.
\end{proof}

\todo{Insbesondere sind alle inklusionsminimalen dünnsten Schnitte -- gegeben eines minimalen $b$-Flusses -- durch die Methode Residualgraph berechenbar (in sehr geringer polynomieller Zeit, nämlich vermutlich sogar $O(n+m)$ -- Allerdings muss man hier bisschen aufpassen, findet man ausgehend von einer maximal ausgelasteten Kante eine weitere, so muss man (für inklusionsminimalität das Vorgehen von hier zurücksetzen)}

\section{Berechnung auslastungsminimaler $b$-Flüsse}

In diesem Abschnitt soll die Berechnung auslastungsminimaler Flüsse beleuchtet werden.
Aufmerksame Leser konnten bereits im vorherigen Abschnitt einige Analogien auslastungsminimaler $b$-Flüsse zu kostenminimalen $b$-Flüssen erkennen.
Bei der Suche nach kostenminimalen $b$-Flüssen werden die Kanten mit Kosten $c\in\R_{\geq 0}^E$ bewertet und man ist daran interessiert einen $b$-Fluss $f$ zu finden, der den Ausdruck $\sum_{e \in E} c_e f_e$ minimiert und dabei die Kapazitäten der Kanten nicht übersteigt, der also $f_e \leq u_e$ für jede Kante $e$ erfüllt.
Dazu betrachtet man ebenfalls den Residualgraph, allerdings mit einem kleinen Unterschied: Vorwärtskanten werden aufgenommen, wenn deren Auslastung geringer als $1$ statt geringer als die Auslastung des Flusses ist.
Ein $b$-Fluss ist kostenminimal genau dann, wenn der zugehörige, so definierte Residualgraph keine negativen Zyklen hat, also Zyklen $C$ mit $\sum_{e\in C} c_e < 0$ (\todo{Add cite}).

Eine Herangehensweise für das Finden eines kostenminimalen Flusses ist es, ausgehend von einem beliebigen $b$-Fluss iterativ Zyklen im Residualgraph durch Augmentieren zu entfernen.
Verwendet man dabei als Auswahlregel, einen Zyklus mit minimalen mittleren Kantenkosten zu entfernen, so terminiert der sogenannte \emph{Minimum-Mean-Cycle-Cancelling-Algorithmus} mit einem kostenminimalen $b$-Fluss nach $\bigO(nm^2\log n)$ Iterationen mit einer Gesamtlaufzeit von $\bigO(n^2m^3 \log n)$ (siehe \cite[Theoreme~3.9, 3.10]{Goldberg1989}).
Verfolgt man den gleichen Ansatz für die Berechnung eines auslastungsminimalen Flusses, erhält man den Algorithmus~\ref{algorithm-cycle-cancelling}.
\begin{algorithm}
	\caption{Cycle-Cancelling-Algorithmus}
	\label{algorithm-cycle-cancelling}
	\begin{algorithmic}[1]
		\Procedure{CycleCancelling}{$V, E, u, b, s$}
		\State Berechne beliebigen $b$-Fluss $f$
		\While{ $\exists$ Zyklus $C$ mit Flaschenhalskante in $G_f$}
			\State Augmentiere $f$ entlang $C$ um einen Wert $\gamma$
		\EndWhile
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Sofort ersichtlich ist, dass der Algorithmus im Falle der Terminierung nach Lemma~\ref{lemma-min-flow-criterion} einen auslastungsminimalen $b$-Fluss liefert.
Unklar bleibt, ob der Algorithmus durch eine passende Wahl der Zyklen und der Augmentierungswerte zum Stehen kommt.
Versucht man beispielsweise $\gamma$ so zu wählen, dass die Auslastung des Zyklus $C$, also $\max_{e\in C} f_e / u_e$, nach der Augmentierung möglichst gering ist, kann die Hoffnung auf Terminierung bereits durch das folgendes Beispiel genommen werden:

\begin{example}
	Man betrachte einen Graphen bestehend aus den zwei Knoten $v$ und $w$ sowie den drei Kanten $e_1$, $e_2$ und $e_3$ von $v$ nach $w$.
	Dabei haben alle Kanten die Kapazität $1$ und man suche einen auslastungsminimalen $v$-$w$-Fluss vom Wert $1$.
	Der eindeutige optimale Fluss weist allen drei Kanten den Wert $1/3$ zu.
	
	Startet man beispielsweise mit dem Fluss, der zunächst den gesamten Fluss über Kante $e_1$ schickt, enthält der Residualgraph die Zyklen $\overrightsmallarrow{e_2}\overleftsmallarrow{e_1}$ und $\overrightsmallarrow{e_3}\overleftsmallarrow{e_1}$.
	Wird entlang einer der beiden Zyklen augmentiert -- o.B.d.A. entlang $\overrightsmallarrow{e_2}\overleftsmallarrow{e_1}$ --, so sind $e_1$ und $e_2$ mit Auslastung $1/2$ die Flaschenhalskanten.
	Im nächsten Schritt können die Zyklen $\overrightsmallarrow{e_3}\overleftsmallarrow{e_1}$ und $\overrightsmallarrow{e_3}\overleftsmallarrow{e_2}$ augmentiert werden.
	Auch hier spielt die Wahl aufgrund der Symmetrie keine Rolle und man augmentiere entlang $\overrightsmallarrow{e_3}\overleftsmallarrow{e_2}$, sodass auf der Flaschenhalskante $e_1$ Fluss von Wert $1/2$ und auf $e_2$ und $e_3$ jeweils Fluss von Wert $1/4$ fließt.
	
	\todo{Überprüfe Deutsch}
	Tatsächlich kann man durch beliebige Wahl der Zyklen den auslastungsminimalen Fluss nicht erreichen, da der Fluss zu jeder Zeit auf zwei Kanten $e_i$ und $e_j$ identisch und auf der übrigen Kante $e_k$ unterschiedlich ist, insbesondere beträgt er nie $1/3$ auf allen drei Kanten gleichzeitig: Ist die Kante $e_k$ Flaschenhalskante und wird o.B.d.A. entlang $\overrightsmallarrow{e_i}\overleftsmallarrow{e_k}$ augmentiert, so wird der Wert von $e_i$ und $e_k$ angeglichen und der Wert von $e_k$ echt erhöht.
	Ist die Kante $e_k$ kein Flaschenhals, so wird im nächsten Schritt entlang eines Zyklus', der $e_k$ und o.B.d.A. $e_i$ enthält, augmentiert; der Fluss von $e_k$ und $e_i$ dadurch angeglichen, sodass sich dieser wieder vom Wert von $e_j$ unterscheidet.
\end{example}

\subsection{Berechnungsmodell}

Um die Laufzeit des nachfolgenden Algorithmus' präzise analysieren zu können, wird zunächst das zugrundeliegende Berechnungsmodell vorgestellt.
Dabei wird wie in~\cite{Gritzmann2013} eine Variante der Random-Access-Machine (RAM) verwendet.
Diese besteht aus einer Recheneinheit und einem unendlich großen Speicher, dessen Speicherzellen anhand der natürlichen Zahlen adressiert werden und jeweils eine ganze Zahl speichern.
Eine RAM kann ein Programm, also eine endliche Folge von elementaren Instruktionen, ausführen.
Eine solche elementare Instruktion ist entweder eine arithmetische Operation, also eine Addition ($+$), Subtraktion ($-$), Multiplikation ($\cdot$) oder ganzzahlige Division ($\div$), oder ein bedingter Sprung, welcher zunächst zwei Operanden mithilfe eines Vergleichers aus $\{ <, \leq, > \geq, =, \neq \}$ vergleicht und im Wahrheitsfall zu einer bestimmten Instruktion wechselt.
Dabei erlaubt die RAM die Angabe der Operanden durch indirekte Adressierung.
\todo{refine RAM}.


Für die Bestimmung der Laufzeit eines Programms $\mathcal{A}$ wird hier das logarithmische Kostenmaß verwendet, um dem zeitlichen Mehraufwand von beispielsweise der Multiplikation großer Zahlen gerecht zu werden:
Demnach benötigt die Ausführung einer elementaren Instruktion $t$ viele Zeiteinheiten, wobei $t$ die Summe der Kodierungslängen der darin genutzten Zahlen (d.h. Speicheradressen und -werte) ist.
Dabei wird für eine ganze Zahl $z$ die binäre Kodierung verwendet, deren Länge $\size{z} := 1 + \lceil \log_2(\abs{z}+1) \rceil$ ist.
Rationale Zahlen $r$ werden als Tupel zweier ganzer Zahlen $(p,q)$ kodiert, sodass $r = p/q$ gilt.
Dabei wird die Kodierungslänge von $r$ als $\size{r}:= \size{p} + \size{q}$ definiert, wobei $p/q$ bereits die Darstellung von $r$ als vollständig gekürzter Bruch ist.
Entsprechend haben rationale Vektoren $v\in\Q^n$ und Matrizen $A\in\Q^{n\times m}$ Kodierungslängen $\size{v} := \sum_{i=1}^n \size{v_i}$ und $\size{A}:= \sum_{i=1}^n\sum_{j=1}^m \size{a_{i,j}}$.

\begin{proposition}\label{prop-rational-bounds-encoding}
	Es seien $a,b\in\Q$ zwei rationale Zahlen, $v\in Q^n$ ein rationaler Vektor und $A\in\Q^{n\times n}$ eine rationale Matrix.
	Dann gelten:
	\begin{enumerate}[label=(\roman*)]
		\item $\size{ab} \leq \size{a}+\size{b}$,
		\item $\norm{v}_2 \leq 2^{\size{v} - n} - 1$,
		\item $\abs{\det(A)} \leq 2^{\size{A} - n^2}$.
	\end{enumerate}
\end{proposition}
\begin{proof}
	Zunächst zeigt man Aussage $(i)$ für ganze Zahlen $a$ und $b$:
	\begin{align*}
		\size{ab} &= 1+\lceil \log_2(\abs{ab} + 1) \rceil \leq 2+\log_2(\abs{a}\abs{b}+1) \leq 2+\log_2((\abs{a}+1)(\abs{b}+1))\\
		&=2+\log_2(\abs{a} + 1) + \log_2(\abs{b} + 1) = \size{a} + \size{b}.
	\end{align*}
	Es seien nun $a$ und $b$ rationale Zahlen und $p_a/q_a$ und $p_b/q_b$ die vollständig gekürzten Bruchdarstellungen von $a$ und $b$.
	Diesen Fall führt man auf den ganzzahligen zurück: \[
	\size{ab} \leq \size{p_a p_b} + \size{q_a q_b} \leq \size{p_a}+\size{p_b} + \size{q_a} + \size{q_b} = \size{a} + \size{b}.\]
	
	Für jede ganze Zahl $z$ gilt außerdem 
	\[
	\abs{z} = 2^{\log_2(\abs{z} + 1)} - 1 \leq 2^{\lceil\log_2(\abs{z} + 1)\rceil} - 1 = 2^{\size{z} - 1} - 1
	\]
	und daher gilt auch für jede rationale Zahl $r = p/q$ in teilerfremder Darstellung
	\[
	\abs{r} \leq \abs{p} \leq 2^{\size{p} -1} - 1 \leq 2^{\size{r} - 1} -1.
	\]
	
	Des Weiteren folgt mit $\sum_{i=1}^n \abs{v_i}^2 \leq (\sum_{i=1}^n \abs{v_i})^2$ die Ungleichung $\norm{v}_2 \leq \norm{v}_1$.
	Eine verallgemeinerte Version der Bernoulli-Ungleichung besagt, dass für nichtnegative Zahlen $x_1,\dots,x_n$ die Ungleichung $\prod_{i=1}^n (1+x_i) \geq 1 + \sum_{i=1}^n x_i$ gilt.
	Dies ist leicht per Induktion über $n\in\N$ einzusehen:
	Der Induktionsanfang ist klar.
	Der Induktionsschritt folgt ebenfalls sehr schnell:
	\[
	\prod_{i=1}^{n+1} (1+x_i) \geq (1 + \sum_{i=1}^n x_i) x_{n+1} = 1 + x_{n+1} + \sum_{i=1}^n x_i + x_{n+1} \sum_{i=1}^n x_i \geq 1 + \sum_{i=1}^{n+1} x_i.
	\]
	Damit lässt sich Aussage $(ii)$ beweisen:
	\[
		\norm{v}_2 \leq \norm{v}_1 \leq \prod_{i=1}^{n} (1+\abs{v_i}) - 1 \leq \prod_{i=1}^n 2^{\size{v_i} - 1} - 1 = 2^{\size{v} - n} - 1.
	\] 
	
	Für Aussage $(iii)$ benötigt man die Hadamard-Ungleichung: Sind $a^1, \dots, a^n$ die Spaltenvektoren von $A$, so gilt $\abs{\det(A)} \leq  \prod_{i=1}^{n} \norm{a^i}_2$.
	Damit folgere man:
	\[
		\abs{\det(A)} \leq \prod_{i=1}^n (2^{\size{a^i} - n} - 1) \leq 2^{\sum_{i=1}^n \size{a^i} - n^2} = 2^{\size{A} - n^2}.
	\]
\end{proof}

Die Laufzeit eines Programms $\mathcal{A}$ bei Eingabe einer Instanz $\mathcal{I}$ einer Problemklasse $\Pi$ ist dann die Summe der Zeitaufwände der einzelnen Instruktionen, die während der Ausführung des Programms bei Eingabe $\mathcal{I}$ durchlaufen werden.

\include{bachelorarbeit/efficient-search-rationals}

\subsection{Berechnung mittels LP-Formulierung}

Um nun mithilfe dieser effizienten Suche auf den rationalen Zahlen, das Problem auslastungsminimaler $b$-Flüsse zu lösen, werden zunächst einige Grundlagen der Linearen Optimierung wiederholt:
\begin{definition}[Lineare Programm in Standardform]
	Ein Optimierungsproblem der Form $\min\{ c^T x \mid x \in P^=(A, b) \}$ mit $c\in\R^n, b\in\R^m, A\in\R^{m\times n}$ und Zulässigkeitsbereich $P^=(A,b):= \{ x\in\R^n \mid Ax = b, x\geq 0 \}$ heißt \emph{lineares Programm in Standardform}.
\end{definition}

\begin{definition}[Ecke konvexer Menge]
	Für eine konvexe Menge $P$ heißt $x\in P$ eine \emph{Ecke von $P$}, falls $x$ das einzige Element des Schnittes von $P$ und einer Stützhyperebene $H:=\{ x\in\R^n \mid d^T x = \delta \}$ mit $d\in\R^n$ und $\delta\in\R$ ist.
\end{definition}

\begin{definition}[Zulässige Basislösung]
Für ein lineares Programm in Standardform mit $P:=P^=(A, b)$ mit $\rank(A) = m$ heißt eine $m$-wertige Teilmenge $B$ von $[n]$ Basis und $N:= [n]\setminus B$ die zugehörige Nichtbasis zu $B$, falls $A_B$ invertierbar ist.
Ein Punkt $x\in P$ ist eine \emph{zulässige Basislösung zur Basis $B$}, falls $x_N$ verschwindet.
In diesem Fall gilt $x_B = A_B^{-1} b$.
\end{definition}

\begin{satz}[{siehe \cite[Satz 5.2.1. (2)]{Jungnickel2008}}]\label{satz-existence-optimality-for-lps}
	Ein lineares Programm in Standardform mit nichtleerem Zulässigkeitsbereich $P:=P^=(A,b)$ und $\rank(A) = m$ hat eine optimale Ecklösung, falls die Zielfunktion $x\mapsto c^T x$ auf $P$ nach unten beschränkt ist.
\end{satz}

\begin{satz}[{siehe \cite[Satz 5.2.3.]{Jungnickel2008}}]\label{satz-ecke-basislsg}
Für ein lineares Programm in Standardform mit nichtleerem Zulässigkeitsbereich $P:=P^=(A,b)$ und $\rank(A) = m$ ist $x\in\R^n$ genau dann eine Ecke von $P$, wenn $x$ eine zulässige Basislösung ist.
\end{satz}

\begin{proposition}\label{prop-rank-obda-m}
	Sei ein nichtleeres Polyeder $P^=(A, b)$ mit $k:=\rank(A)$ und linear unabhängigen Zeilen $a_{i_1},\dots, a_{i_k}$ gegeben.
	Setzt man \[
	\tilde{A}:= (a_{i_1}, \dots, a_{i_k})^T\text{~ und ~}\tilde{b}:= (b_{i_1}, \dots, b_{i_k})^T, \]
	 so hat $\tilde{A}$ Rang $k$ und es gilt $P^=(A,b) = P^=(\tilde{A}, \tilde{b})$.
\end{proposition}
\begin{proof}
	Die Teilmenge $P^=(A,b)\subseteq P^=(\tilde{A}, \tilde{b})$ ist klar:
	Gelten für ein $x\in\R^n_{\geq0}$ alle Ungleichungen von $Ax \leq b$, so erst recht alle der Teilmenge $\tilde{A}x \leq \tilde{b}$.
	
	Da der Zeilenrang von $A$ gerade $k$ ist, existiert für jede Zeile $a_j$ eine Linearkombination $a_j=\sum_{l=1}^k \lambda_l a_{i_l}$ aus den Zeilen in $\tilde{A}$.
	Da $P^=(A,b)$ nichtleer ist, existiert ein $y$ darin, welches die Gleichung
	$b_j = a_j y = \sum_{l=1}^k \lambda_l a_{i_l} y = \sum_{l=1}^k \lambda_l b_{i_l}$ liefert.
	Für alle $x\in P^=(\tilde{A}, \tilde{b})$ gilt also $a_j x = \sum_{l=1}^k \lambda_l a_{i_l} x = \sum_{l=1}^k \lambda_l b_{i_l} = b_j$.
\end{proof}

\begin{lemma}\label{lemma-optimal-value-in-finite-domain}
	Es sei ein lineares Programm in Standardform mit nichtleerem Zu\-lässig\-keits\-bereich $P:= P^=(A,b)$ und ganzzahligen Parametern $A\in \Z^{m\times n}$, $b\in\Z^m$ und $c\in\Z^n$, sodass $x\mapsto c^T x$  auf $P$ nach unten beschränkt ist.
	Es sei $c_{\max}$ der betraglich größte Eintrag in $c$.
	Ist weiter $k$ die Anzahl der Koordinaten, in denen $c$ nicht verschwindet, so liegt der optimale Zielfunktionswert in der endlichen Menge
	\[
	\left\{ \frac{p}{q} ~\middle|~ p\in\Z, q\in\N, \abs{p} \leq k \abs{c_{\max}} 2^{\size{A} + \size{b} -m(n + 1)}, 1\leq q \leq 2^{\size{A}-mn} \right\}.
	\]
\end{lemma}
\begin{proof}
	Es sei $\tilde{A}$ die Teilmatrix von $A$, die $r:=\rank{A}$ linear unabhängige Zeilen von $A$ enthält; $\tilde{b}$ sei der entsprechende Teilvektor von $b$.
	Dann stimmen die Polyeder $P^=(A,b)$ und $P^=(\tilde{A}, \tilde{b})$ nach Proposition~\ref{prop-rank-obda-m} überein.
	Mit den Sätzen~\ref{satz-existence-optimality-for-lps} und~\ref{satz-ecke-basislsg} folgt, dass es eine optimale Basislösung $x^*$ gibt.
	Ist $B$ die Basis von $x^*$, so ist $x^*$ auf den Koordinaten von $B$ gerade $\tilde{A}_B^{-1} \tilde{b}$, sodass die Cramersche Regel die Darstellung $x_i^* = \det(\tilde{A}_B^i) / \det(\tilde{A}_B)$ für jede Koordinate $i\in B$ liefert.
	Dabei ist $\tilde{A}_B^i$ die Matrix, die aus $\tilde{A}_B$ durch Ersetzen der $i$-ten Spalte durch $\tilde{b}$ entsteht.
	Für die Kodierungslänge von $\tilde{A}_B$ ergibt sich die obere Schranke $\size{A} - (mn - r^2)$, da für jeden Eintrag, der in $A$ und nicht in $\tilde{A}_B$ vorkommt, eine Kodierungslänge von mindestens $1$ hinzukommt.
	Entsprechend ist $\size{A} + \size{b} - (mn + m - r^2)$ eine obere Schranke an die Kodierung von $\tilde{A}_B^i$ für alle $i\in B$.
	
	Der optimale Zielfunktionswert hat die Form \[
	c^T x^* = 
	\frac{\sum_{i\in B} c_i \det(A_B^i)}{\det(A_B)}.
	\]
	Der Zähler wird nun mit Proposition~\ref{prop-rational-bounds-encoding} wie folgt abgeschätzt:
	\[
	\left| { \sum_{i\in B} c_i \det(A_B^i) } \right| \leq \sum_{i\in B} \abs{c_{\max}} 2^{\size{\tilde{A}_B^i}- r^2} \leq k \abs{c_{\max}} 2^{\size{A} + \size{b} - m(n+1)}
	\]
	Der Nenner ist betraglich durch $2^{\size{\tilde{A}_B} - r^2}\leq 2^{\size{A} - mn}$ beschränkt, sodass die Aussage folgt.
\end{proof}

Da das Maschinenmodell nur auf Zahlen mit endlicher Kodierung arbeiten kann, wird die Eingabe des Problems zunächst auf rationale Zahlen beschränkt, sodass folgende Problemstellung (MCF) entsteht:

\begin{centering}
	\begin{framed}
		\emph{Minimum Congestion Flow (MCF)} \\[1em]
		\begin{tabular}{rl}
			{\bfseries Input}: &$b$-Fluss-Instanz $(V, E, b\in\Q^V, u \in \Q^E_{>0})$\\
			{\bfseries Output}: &Auslastungsminimaler $b$-Fluss $f$
		\end{tabular}
	\end{framed}
\end{centering}

Ein Algorithmus, der (MCF) löst, soll zudem mit einer Fehlermeldung abbrechen, falls kein $b$-Fluss existiert.
Zunächst wird (MCF) als lineares Optimierungsproblem formuliert.
Dabei minimieren wir die Zahl $q^*$, sodass $b$-Flüsse existieren, deren Auslastung $q^*$ nicht überschreitet:
\begin{equation}\tag{LP}\label{problem-lp-minimal-flow}
\begin{aligned}
& \min q^* \\[1em]
\text{u.d.N.\quad} & \sum_{e\in \delta^+(v)} f_e - \sum_{e\in\delta^-(v)} f_e = b_v & \text{für alle $v\in V$,} \\[1em]
& 0 \leq \frac{f_e}{u_e} \leq q^* & \text{für alle $e\in E$.}
\end{aligned}
\end{equation}

Schnell ist ersichtlich, dass $f$ für eine optimale Lösung $(q^*, f)$ von~(\ref{problem-lp-minimal-flow}) auch ein auslastungsminimaler $b$-Fluss ist: Die $b$-Fluss-Eigenschaft folgt bereits aus der ersten Bedingung und aus der Nichtnegativität von $f_e / u_e$.
Die Auslastungsminimalität von $f$ in~(\ref{problem-lp-minimal-flow}) wird durch die Minimierung der oberen Schranke $q^*$ aller $f_e / u_e$ sichergestellt.
Umgekehrt ist $(c(f), f)$ eine optimale Lösung von~(\ref{problem-lp-minimal-flow}) für einen auslastungsminimalen $b$-Fluss $f$.


\begin{corollary}\label{cor-minimal-congestion-limited}
	Existiert für eine $b$-Fluss-Instanz $(V, E, b\in\Q^V, u\in\Q^E_{>0})$ ein $b$-Fluss, so ist die Auslastung $q^*$ eines auslastungsminimalen $b$-Flusses enthalten in
	\[
	\left\{ \frac{p}{q} ~\middle|~ p\in\N_0, q\in\N_1, p,q \leq 8^{\size{b} + \size{u} } \right\}.
	\]
\end{corollary}
\begin{proof}
Formuliert man~(\ref{problem-lp-minimal-flow}) als lineares Programm in Standardform, so führt man für die Ungleichungen der Form $f_e/u_e \leq q^*$ Schlupfvariablen $y\in\R^E$ ein und erhält:
\newcommand{\nil}{\mathbf{0}}
\newcommand{\one}{\mathbf{1}}
\[
	A = \begin{pmatrix}
		B & \nil_{n\times m} & \nil_{n\times 1} \\
		\one_{m\times m} & \one_{m\times m} & -u
	\end{pmatrix} \in \Q^{(n+m) \times (2m+1)},
	\tilde{b} = \begin{pmatrix}
		b \\
		\nil_{m\times 1}
	\end{pmatrix} \in \Q^{n+m}.
\]
Dabei ist $B$ die Inzidenzmatrix des schleifenfreien Graphen, das heißt, nennt man die Kanten $e_1, \dots, e_m $ und die Knoten $v_1, \dots, v_n$, setzt man  für alle $i\in [n]$ und $j\in [m]$
\[ 
	b_{i,j} := \begin{cases}
		1, & \text{falls $v_i = \head(e_j)$}, \\
		-1, & \text{falls $v_i = \tail(e_j)$},\\
		0, & \text{sonst.}
	\end{cases}
\]
 Die zugehörigen Entscheidungsvariablen sind $(f, y, q^*)^T\in\R_{\geq 0}^{2m+1}$, die Zielfunktion ist definiert durch $x\mapsto c^T x$ mit $c = (\nil_{1\times 2m}, 1)^T$.
 
Multipliziert man nun für $i\in [n]$ die $i$-te Zeile von $A$ und $\tilde{b}$ mit dem Nenner von $b_i$ und für $i\in [m]$ die $(n+i)$-te Zeile mit dem Nenner von $u_i$, so erhält man eine ganzzahlige Matrix $\hat{A}$ und einen ganzzahligen Vektor $\hat{b}$.
Die Kodierungslänge der ersten $n$ Zeilen von $\hat{A}$ beträgt höchstens $2\size{b} + (n-2)m) + nm + n = 2\size{b} + 2nm -2m + n$.
Die restlichen $m$ Zeilen haben eine Kodierungslänge von höchstens $3\size{u} + 2m^2 - 2m$.
Der Vektor $\hat{b}$ hat eine Kodierungslänge von höchstens $\size{b} + m$.

Lemma~\ref{lemma-optimal-value-in-finite-domain} wird nun genutzt, um das Resultat zu folgern.
Dazu werden die folgenden beiden Abschätzungen benötigt:
\begin{align*}
\size{\hat{A}} + \size{\hat{b}} - (n+m)(2m+2) &= \size{\hat{A}} + \size{\hat{b}} - 2mn - 2n - 2m^2 - 2m\\
&\leq 2 \size{b} + 3\size{u} + \size{\hat{b}} - n - 6m \leq 3\size{b} + 3\size{u} -n-5m, \\[1em]
\size{\hat{A}} - (m+n)(2m + 1) &= \size{\hat{A}} - 2m^2 - m - 2mn - n\\
&\leq 2\size{b} + 3\size{u} - 5m.
\end{align*}
\end{proof}

\begin{theorem}
	Eine Instanz $(V,E,b,u)$ des (MCF)-Problems kann mit $\bigO(\size{b} + \size{u})$ Berechnungen eines maximalen Flusses auf einem Graphen der Größe von $(V,E)$ gelöst werden.
\end{theorem}
\begin{proof}
	Es sei zunächst $\mathbf{b}$ die Summe aller positiven $b_v$ für $v\in V$.
	Dies ist gerade das Negative der Summe aller negativen $b_v$ für $v\in V$, denn sonst wäre $b$ kein zulässiger Balance-Vektor, für den es von vornherein keinen $b$-Fluss gibt.
	
	Angenommen, es existiere ein $b$-Fluss, so ist die minimale Auslastung $q^*$ eines $b$-Flusses nach Korollar~\ref{cor-minimal-congestion-limited} eine nichtnegative, rationale Zahl, deren Zähler und Nenner durch $8^{\size{b} + \size{u}}$ beschränkt sind.
	Nach Theorem~\ref{theorem-find-rational} kann $q^*$ durch $\bigO(\size{b} + \size{u})$ Vergleiche der Form \glqq Ist $q^*\leq p/q$?\grqq\ ermittelt werden.
	
	Ein solcher Vergleich kann wie folgt umgesetzt werden:
	Der Graph $(V,E)$ wird um zwei Knoten, eine sog. Superquelle $s$ und Supersenke $t$, augmentiert.
	Für jeden Knoten $v\in V$ mit $b_v > 0$ wird eine Kante $(s,v)$ mit Kapazität $\nu_{(s,v)}:= b_v$ eingefügt; für einen Knoten $v\in V$ mit $b_v < 0$ wird eine Kante $(v,t)$ mit Kapazität $\nu_{(v,t)}:= -b_v$ erstellt.
	Für bereits bestehende Kanten $e\in E$ wird die Kapazität auf $\nu_e := u_e \cdot  p / q$ gesetzt.
	
	Dann hat ein maximaler $s$-$t$-Fluss $f$, der die Kantenkapazitäten $\nu$  einhält, der also $f_e\leq \nu_e$ für alle $e\in E$ erfüllt, genau dann Wert $\mathbf{b}$, wenn $q^*\leq p/q$ gilt:
	Für einen maximalen $s$-$t$-Fluss $f$ mit $f\leq \nu$ und Wert $\mathbf{b}$ ist $f$ eingeschränkt auf $E$ ein $b$-Fluss, denn offenbar sind hier alle Kanten der Form $(s,v)$ bzw. $(v,t)$ hinsichtlich $\nu_{(s,v)}$ bzw. $\nu_{(v,t)}$ voll ausgelastet.	
	Da diese Kanten durch Einschränkung auf $E$ wegfallen und $v$ bzgl. $f$ Flusserhaltung gewährt hat, gilt $\sum_{e\in\delta^+_E(v)} f_e - \sum_{e\in\delta^-_E(v)} f_e = b_v$.
	Außerdem gilt $f_e/u_e \leq p/q$ für alle Kanten $e\in E$.
	Insbesondere ist $q^*\leq p/q$.
	Ist andersherum $f$ ein $b$-Fluss mit Auslastung $q^*\leq p/q$, so ist der Fluss $\tilde{f}$, der $f$ um $\tilde{f}_{(s,v)}:=b_v$ für $b_v > 0$ und $\tilde{f}_{(v,t)}:= -b_v$ für $b_v < 0$ augmentiert, ein maximaler $s$-$t$-Fluss, der die Kapazitäten $\nu$ einhält.
	
	Außerdem kann man herausfinden, ob ein $b$-Fluss überhaupt existiert, indem man wie oben überprüft, ob ein maximaler $s$-$t$-Fluss den Wert $\mathbf{b}$ hat, wenn man $\nu_e=\infty$ für $e\in E$ setzt.
\end{proof}

Hier kann man nun aus den zahlreichen Algorithmen zur Berechnung von maximalen Flüssen wählen.
Verwendet man beispielsweise den wohlbekannten Push-Relabel-Algorithmus von Goldberg-Tarjan, \todo{add cite} so kann ein maximaler $s$-$t$-Fluss in $\bigO(\abs{V}^2\abs{E})$ Operationen berechnet werden.
Die Ergebnisse werden nun im folgenden Theorem gesammelt.

\begin{theorem}\label{thm-compute-minimal-con-flow}
	Ein auslastungsminimaler $b$-Fluss kann mit $\bigO((\size{b}+\size{u}) n^2 m)$ arithmetischen Operationen auf Zahlen mit Kodierungslänge $\bigO(\size{b} + \size{u})$ berechnet werden, wodurch sich eine Laufzeit von $\bigO((\size{b}+\size{u})^2 n^2 m)$ ergibt.
	Dabei sind $n$ die Anzahl der Knoten und $m$ die Anzahl der Kanten im Graphen.
\end{theorem}